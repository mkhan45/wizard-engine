// GENERATED BY InterpreterGen.v3
class CBDWasmStack(cbd_interpreter: CBDV3Interpreter) extends WasmStack {
    def it = cbd_interpreter.it;
    def state() -> StackState => it.state();
    def reset(func: Function) -> this { it.reset(func); }
    def bind(args: Range<Value>) -> this { it.bind(args); }
    def resume() -> Result {
        it.thrown = null;
        it.goto_stack = null;
        if (it.frame.pc == 0) it.codeptr.iterate_local_codes(it.pushLocals);
        def tags = it.frame.func.decl.frame_var_tags;
        if (tags != null) for (t in tags) it.values.push(it.tagToValue(t));

        while (it.state_ == StackState.RUNNING && it.frame != null) {
            it.frame.pc = it.codeptr.pos;
            def opcode = it.codeptr.read_opcode();
            cbd_interpreter.DISPATCH_TABLE[opcode.tag]();
        }

        // TODO: match on result
        def top = it.values.top;
        def vals = Ranges.dup(it.values.peekn(it.return_arity));
        it.clear();
        return Result.Value(vals);
    }
    // def where = it.where;
    // def caller = it.caller;
    // def clear = it.clear;
    // def tryHandleSuspension = it.tryHandleSuspension;
    // def tryHandleSwitch = it.tryHandleSwitch;
}

def conv_i32_op(op: (i32, i32) -> i32) -> ((u32, u32) -> u32) => fun (x, y) => u32.view(op(i32.view(x), i32.view(y)));
def conv_i32_testop(op: (i32, i32) -> bool) -> ((u32, u32) -> bool) => fun (x, y) => op(i32.view(x), i32.view(y));

def conv_i64_op(op: (i64, i64) -> i64) -> ((u64, u64) -> u64) => fun (x, y) => u64.view(op(i64.view(x), i64.view(y)));
def conv_i64_testop(op: (i64, i64) -> bool) -> ((u64, u64) -> bool) => fun (x, y) => op(i64.view(x), i64.view(y));

class CBDV3Interpreter(it: V3Interpreter) {
    // can't extend V3Interpreter directly bc some intrinsics overlap with method names

    def HAS_MEM_INDEX = 0x40u8;
    var DISPATCH_TABLE: Array<void -> void>;

    var sidetables: Array<Array<u8>>;

    // for wizeng
    def init_module(module: Module) {
        DISPATCH_TABLE = build_dispatch_table();
        Validator.init(module, []);
    }

    // for InterpreterMain
    def init(instance: Instance, args: Array<int>) {
        def module = instance.module;
        DISPATCH_TABLE = build_dispatch_table();
        for (op in Opcode) if (op.tag < DISPATCH_TABLE.length) { // XXX: why bounds check?
            // if (DISPATCH_TABLE[op.tag] == null) DISPATCH_TABLE[op.tag] = fun => it.execOp(it.frame.pc, op);
            if (DISPATCH_TABLE[op.tag] == null) DISPATCH_TABLE[op.tag] = trapUnreachable;
        }

        var main_idx = -1;
        for (i < module.exports.length) {
            if (Strings.equal(module.exports[i].0, "main")) main_idx = FuncDecl.!(module.exports[i].1).func_index;
        }

        sidetables = Array.new(module.functions.length);
        Validator.init(module, args);
        for (i < module.functions.length) {
            def fn = CBDFunction.new(module.functions[i]);
            Validator.init_function(fn.code, fn.args.copy(), fn.locals.copy(), fn.rets.copy());
            Validator.dispatch();
            sidetables[i] = Validator.build_sidetable();
            System.puts("validated ");
            System.puti(i);
            System.ln();
        }

        it.reset(instance.functions[main_idx]);
    }

    def dispatch() {
        it.codeptr.iterate_local_codes(it.pushLocals);
        def tags = it.frame.func.decl.frame_var_tags;
        if (tags != null) for (t in tags) it.values.push(it.tagToValue(t));

        while (it.frame != null && it.codeptr.available() > 0) {
            it.frame.pc = it.codeptr.pos;
            def opcode = it.codeptr.read_opcode();
            // System.puti(it.frame.pc); System.puts(": "); printStack();
            // System.puts(opcode.mnemonic); System.ln();
            DISPATCH_TABLE[opcode.tag]();
        }
    }

    def get_stack() => it.values;

    def module() => it.frame.func.instance.module;
    def functions() => it.frame.func.instance.module;

    def imm_readULEB32() -> u32 => it.codeptr.read_uleb32();
    def imm_readULEB64() -> u64 => it.codeptr.read_uleb64();

    def imm_readILEB32() -> u32 => u32.view(it.codeptr.read_sleb32());
    def imm_readILEB64() -> u64 => u32.view(it.codeptr.read_sleb64());

    def imm_readU8() -> u8 => it.codeptr.read1();

    def imm_readBlockType() -> (Array<ValueType>, Array<ValueType>) {
        def bt = it.codeptr.read_BlockTypeCode();
        return bt.toAbstractBlockType(module());
    }

    def pop_u32: void -> u32 = it.popu;
    def pop_u64: void -> u64 = it.popw;
    def pop_f32: void -> float = it.popf;
    def pop_f64: void -> double = it.popd;
    def pop_v128() -> v128;
    def pop_Object: void -> Object = it.popObject;
    def pop_Value(tv: ()) -> Value => it.pop();

    def push_u32: u32 -> void = it.pushu;
    def push_u64: u64 -> void = it.pushw;
    def push_f32: float -> void = it.pushf;
    def push_f64: double -> void = it.pushd;
    def push_v128(v: v128);
    def push_Object(v: Object) => it.values.push(Value.Ref(v));
    def push_Value(tv: (), v: Value) => it.values.push(v);

    // Local variables.
    def getLocal(tv: (), index: u32) -> Value {
        return it.values.elems[it.frame.fp + int.view(index)];
    }
    def setLocal(tv: (), index: u32, v: Value) {
        it.values.elems[it.frame.fp + int.view(index)] = v;
    }

    // Global variables.
    def getGlobal(tv: (), index: u32) -> Value {
        // XXX: should use Runtime.GLOBAL_GET?
        return it.frame.func.instance.globals[int.view(index)].get();
    }
    def setGlobal(tv: (), index: u32, v: Value) {
        it.frame.func.instance.globals[int.view(index)].set(v);
    }

    // XXX: is a label always a SidetableBrEntry?
    // def f_getLabel(depth: u32) -> SidetableBrEntry {
    //     def stp = it.frame.stp, sidetable = it.frame.func.decl.sidetable;
    //     return sidetable.getBrEntry(stp);
    // }

    def f_getLocalType(index: u32) -> () {
        return ();
    }

    def f_getTopOfStackType() -> () {
        return ();
    }

    // Module context.
    def m_getGlobalType(index: u32) -> () {
        return ();
    }
    def m_getFieldKind(struct_index: u32, field_index: u32) -> FieldKind {
        def ht = module().heaptypes[int.view(struct_index)];
        def decl = StructDecl.!(ht);
        def st = decl.field_types[field_index];
        match (st.valtype) {
            BOTTOM => return FieldKind.REF;
            I32 => return FieldKind.U32;
            I64 => return FieldKind.U64;
            F32 => return FieldKind.F32;
            F64 => return FieldKind.F64;
            V128 => return FieldKind.V128;
            Host => return FieldKind.REF;
            Ref => return FieldKind.REF;
        }
    }
    def m_getFieldOffset(struct_index: u32, field_index: u32) -> u32 {
        return u32.!(field_index); // XXX?
    }
    def m_isMemory64(memory_index: u32) -> bool => false; // TODO mem64
    def m_isTable64(memory_index: u32) -> bool => false;
    def m_getFuncSignature(func_index: u32) -> SigDecl {
        return null; // already in CBDFunction, TODO: refactor
    }
    def m_getSignature(sig_index: u32) -> HeapTypeDecl {
        return module().heaptypes[int.view(sig_index)];
    }

    // Instance context.
    def i_getTableFunction64(table_index: u32, sig: HeapTypeDecl, func_index: u64) -> Function;
    def i_getTableFunction32(table_index: u32, sig: HeapTypeDecl, func_index: u32) -> Function {
        // lookupIndirect
        def instance = it.frame.func.instance;
        def table = instance.tables[int.view(table_index)];
        if (int.view(func_index) >= table.elems.length) trapTableOOB();
        def expected = SigDecl.!(sig);
        def f = table.funcs[int.view(func_index)];
        if (f == null) trapNull();
        if (!ValueTypes.isAssignableHeap(f.sig, expected)) trapFuncSigMismatch();
        return f;
    }
    def i_getFunction(func_index: u32) -> Function {
        return it.frame.func.instance.functions[int.view(func_index)];
    }

    // Control flow.
    def doCall(sig: Decl, target: Function) {
        it.doCallFunction(target);
        it.codeptr.iterate_local_codes(it.pushLocals);
        def tags = it.frame.func.decl.frame_var_tags;
        if (tags != null) for (t in tags) it.values.push(it.tagToValue(t));
    }
    def doReturnCall(sig: Decl, target: Function) {
        it.prepareReturnCall(SigDecl.!(sig));
        it.doCallFunction(target);
    }

    def doBranch(label: Ref<Sidetable_BrEntry>) {
        // doCtlXfer
        it.codeptr.at(it.frame.pc + label.pc_delta);
        it.frame.stp += label.stp_delta - Sidetable_BrEntry.size;
        if (label.popcount > 0) {
            if (label.valcount > 0) it.copyVals(label.valcount, it.values.top - int.!(label.popcount + label.valcount));
            else it.values.top -= label.popcount;
        }
    }

    def doSwitch(n_labels: u32, key: u32) {
        def fn_idx = it.frame.func.decl.func_index, sidetable = sidetables[fn_idx];
        def index = if(key >= n_labels, int.view(n_labels)-1, int.view(key));
        it.frame.stp += (index * Sidetable_BrEntry.size);
        it.frame.pc += index;

        def br_entry = Ref<Sidetable_BrEntry>.at(sidetable, it.frame.stp);
        doBranch(br_entry);
    }

    def doFallthru() {
        // it seems intuitive that getting the sidetable entry increments the stp
        // instead of falling through
        // it.frame.stp += 4;
    }

    // Machine intrinsics.
    def mach_readStructField_u8(obj: Object, offset: i32) -> u8;
    def mach_readStructField_u16(obj: Object, offset: i32) -> u16;
    def mach_readStructField_u32(obj: Object, offset: i32) -> u32 {
        def s = HeapStruct.!(obj);
        return Values.unbox_u(s.vals[offset]);
    }
    def mach_readStructField_u64(obj: Object, offset: i32) -> u64;
    def mach_readStructField_f32(obj: Object, offset: i32) -> float;
    def mach_readStructField_f64(obj: Object, offset: i32) -> double;
    def mach_readStructField_v128(obj: Object, offset: i32) -> v128;
    def mach_readStructField_Object(obj: Object, offset: i32) -> Object {
        def s = HeapStruct.!(obj);
        def r = Value.Ref.!(s.vals[offset]);
        return r.val;
    }

    // XXX: should Object always be HeapObject?
    def object_Null() -> Object => null;
    def object_isNull(o: Object) => o == null;
    // should see how much we can leverage Runtime.v3
    def object_New(sig: HeapTypeDecl) -> Object {
        def decl = StructDecl.!(sig);
        def fields = Array<Value>.new(decl.field_types.length);
        for (i = fields.length - 1; i >= 0; i -= 1) {
            fields[i] = pop_Value(());
        }
        return HeapStruct.new(decl, fields);
    }

    // XXX: should look more closely at what v3interpreter does
    def doRead32<R, T>(
        memory_index: u32, index: u32, offset: u32, read: (Memory, u32, u32) -> MaybeTrap<R>, view: R -> T
    ) -> T {
        def memory = it.frame.func.instance.memories[int.view(memory_index)];
        def read_res = read(memory, u32.view(offset), u32.view(index));
        if (read_res.trapped()) trapMem();
        return view(read_res.result);
    }


    def mach_readMemory64_u8(memory_index: u32, index: u64, offset: u64) -> u8;
    def mach_readMemory32_u8(memory_index: u32, index: u32, offset: u32) =>
        doRead32<u8, u8>(memory_index, index, offset, Memory.read_u8, u8.view);
    def mach_readMemory64_u16(memory_index: u32, index: u64, offset: u64) -> u16;
    def mach_readMemory32_u16(memory_index: u32, index: u32, offset: u32) =>
        doRead32<u16, u16>(memory_index, index, offset, Memory.read_u16, u16.view);
    def mach_readMemory64_u32(memory_index: u32, index: u64, offset: u64) -> u32;
    def mach_readMemory32_u32(memory_index: u32, index: u32, offset: u32) =>
        doRead32<u32, u32>(memory_index, index, offset, Memory.read_u32, u32.view);
    def mach_readMemory64_u64(memory_index: u32, index: u64, offset: u64) -> u64;
    def mach_readMemory32_u64(memory_index: u32, index: u32, offset: u32) =>
        doRead32<u64, u64>(memory_index, index, offset, Memory.read_u64, u64.view);
    def mach_readMemory64_f32(memory_index: u32, index: u64, offset: u64) -> float;
    def mach_readMemory32_f32(memory_index: u32, index: u32, offset: u32) =>
        doRead32<float, float>(memory_index, index, offset, Memory.read_float, fun x => x);
    def mach_readMemory64_f64(memory_index: u32, index: u64, offset: u64) -> double;
    def mach_readMemory32_f64(memory_index: u32, index: u32, offset: u32) =>
        doRead32<double, double>(memory_index, index, offset, Memory.read_double, fun x => x);

    // XXX: should look more closely at what v3interpreter does
    def doWrite32<P, T>(
        memory_index: u32, index: u32, offset: u32, val: P, write: (Memory, u32, u32, T) -> TrapReason, view: P -> T
    ) {
        def memory = it.frame.func.instance.memories[int.view(memory_index)];
        def t = write(memory, u32.view(offset), u32.view(index), view(val));
        if (t != TrapReason.NONE) trapMem();
    }
    def mach_writeMemory64_u8(memory_index: u32, index: u64, offset: u64, val: u32);
    def mach_writeMemory32_u8(memory_index: u32, index: u32, offset: u32, val: u32) =>
        doWrite32<u32, u8>(memory_index, index, offset, val, Memory.write_u8, u8.view);
    def mach_writeMemory64_u16(memory_index: u32, index: u64, offset: u64, val: u32);
    def mach_writeMemory32_u16(memory_index: u32, index: u32, offset: u32, val: u32) =>
        doWrite32<u32, u16>(memory_index, index, offset, val, Memory.write_u16, u16.view);
    def mach_writeMemory64_u32(memory_index: u32, index: u64, offset: u64, val: u32);
    def mach_writeMemory32_u32(memory_index: u32, index: u32, offset: u32, val: u32) =>
        doWrite32<u32, u32>(memory_index, index, offset, val, Memory.write_u32, u32.view);
    def mach_writeMemory64_u64(memory_index: u32, index: u64, offset: u64, val: u64);
    def mach_writeMemory32_u64(memory_index: u32, index: u32, offset: u32, val: u64) =>
        doWrite32<u64, u64>(memory_index, index, offset, val, Memory.write_u64, u64.view);

    def mach_writeMemory64_f32(memory_index: u32, index: u64, offset: u64, val: float);
    def mach_writeMemory32_f32(memory_index: u32, index: u32, offset: u32, val: float) =>
        doWrite32<float, float>(memory_index, index, offset, val, Memory.write_float, fun x => x);
    def mach_writeMemory64_f64(memory_index: u32, index: u64, offset: u64, val: double);
    def mach_writeMemory32_f64(memory_index: u32, index: u32, offset: u32, val: double) =>
        doWrite32<double, double>(memory_index, index, offset, val, Memory.write_double, fun x => x);

    def mach_readTable64(table_index: u32, index: u64) -> Object;
    def mach_readTable32(table_index: u32, index: u32) -> Object {
        def table = it.frame.func.instance.tables[int.view(table_index)];
        def elems = table.elems;
        if (index >= elems.length) {
            trapTableOOB();
        }
        return Values.unbox(elems[index]);
    }

    def mach_writeTable64(table_index: u32, index: u64, val: Object);
    def mach_writeTable32(table_index: u32, index: u32, val: Object) {
        def table = it.frame.func.instance.tables[int.view(table_index)];
        def elems = table.elems;
        if (index >= elems.length) {
            trapTableOOB();
        }
        table[int.view(index)] = Value.Ref(val);
    }

    // Traps.
    def invalid(); // should never occur
    def trapNull();
    def trapUnreachable();
    def trapDivideByZero();
    def trapDivideUnrepresentable();
    def trapMem();
    def trapTableOOB();
    def trapFuncSigMismatch();

    def doBlock(bt: (Array<ValueType>, Array<ValueType>)) {
    }

    def doLoop(bt: (Array<ValueType>, Array<ValueType>)) {
    }

    // def doIf(bt: (Array<ValueType>, Array<ValueType>)) -> SidetableBrEntry {
    //     return it.frame.func.decl.sidetable.getBrEntry(it.frame.stp);
    // }

    // def doElse() -> SidetableBrEntry {
    //     return it.frame.func.decl.sidetable.getBrEntry(it.frame.stp);
    // }

    def doEnd() {
        // CBD calls doReturn if at end
    }

    def doReturn() {
        def fp = it.frame.fp;
        def sig = it.frame.func.sig;
        it.doReturn(fp, sig);
    }

    def doTry(bt: (Array<ValueType>, Array<ValueType>)) {
        return;
    }

    def f_isAtEnd() -> bool {
        return it.codeptr.available() == 0;
    }

    def f32_reinterpret_u32(i: u32) -> float;
    def f64_reinterpret_u64(i: u64) -> double;
    def u32_reinterpret_f32(f: float) -> u32;
    def u64_reinterpret_f64(f: double) -> u64;

     // XXX: traps
    def U32_div_s = conv_i32_op(i32./);
    def U32_rem_s = conv_i32_op(i32.%);
    def U32_rem_u(x: u32, y: u32) => x % y;
    def U32_lt_s = conv_i32_testop(i32.<);
    def U32_le_s = conv_i32_testop(i32.<=);
    def U32_gt_s = conv_i32_testop(i32.>);
    def U32_ge_s = conv_i32_testop(i32.>=);
    def U32_ge_u(x: u32, y: u32) => x >= y;

    def U32_clz = V3Eval.I32_CLZ;
    def U32_ctz = V3Eval.I32_CTZ;
    def U32_popcnt = V3Eval.I32_POPCNT;
    def U32_shl = conv_i32_op(V3Eval.I32_SHL);
    def U32_shr_u = conv_i32_op(V3Eval.I32_SHR_U);
    def U32_shr_s = conv_i32_op(V3Eval.I32_SHR_S);
    def U32_rotl = V3Eval.I32_ROTL;
    def U32_rotr = V3Eval.I32_ROTR;
    def U32_extend8_s(x: u32) => u32.view(V3Eval.I32_EXTEND8_S(int.view(x)));
    def U32_extend16_s(x: u32) => u32.view(V3Eval.I32_EXTEND16_S(int.view(x)));

    def U64_div_s = conv_i64_op(i64./);
    def U64_rem_s = conv_i64_op(i64.%);
    def U64_rem_u(x: u64, y: u64) => x % y;
    def U64_lt_s = conv_i64_testop(i64.<);
    def U64_le_s = conv_i64_testop(i64.<=);
    def U64_gt_s = conv_i64_testop(i64.>);
    def U64_ge_s = conv_i64_testop(i64.>=);
    def U64_ge_u(x: u64, y: u64) => x >= y;

    def U64_clz = V3Eval.I64_CLZ;
    def U64_ctz = V3Eval.I64_CTZ;
    def U64_popcnt = V3Eval.I64_POPCNT;
    def U64_shl = V3Eval.I64_SHL;
    def U64_shr_u = V3Eval.I64_SHR_U;
    def U64_shr_s = conv_i64_op(V3Eval.I64_SHR_S);
    def U64_rotl = V3Eval.I64_ROTL;
    def U64_rotr = V3Eval.I64_ROTR;
    def U64_extend8_s(x: u64) => u64.view(V3Eval.I64_EXTEND8_S(int.view(x)));
    def U64_extend16_s(x: u64) => u64.view(V3Eval.I64_EXTEND16_S(int.view(x)));
    def U64_extend32_s(x: u64) => u64.view(V3Eval.I64_EXTEND32_S(int.view(x)));

    def get_st_entry(size: int) -> Range<u8> {
        def stp = it.frame.stp;
        def fn_idx = it.frame.func.decl.func_index;
        def sidetable = sidetables[fn_idx];

        it.frame.stp += size;
        return sidetable[stp ... stp + size];
    }

    def printStack() {
		var out = StringBuilder.new();
        out.putc('[');
        for (i < it.values.top) {
            out.putq(Values.render(it.values.elems[i], _));
            if (i + 1 < it.values.top) out.puts(", ");
        }
        out.putc(']');
        out.ln();
        System.puts(out.toString());
	}

def UNREACHABLE() {
	trapUnreachable();
}
def NOP() {
}
def LOCAL_GET() {
	def index = imm_readULEB32();
	def tv = f_getLocalType(index);
	def val = getLocal(tv, index);
	push_Value(tv, val);
}
def LOCAL_SET() {
	def index = imm_readULEB32();
	def tv = f_getLocalType(index);
	def val = pop_Value(tv);
	setLocal(tv, index, val);
}
def LOCAL_TEE() {
	def index = imm_readULEB32();
	def tv = f_getLocalType(index);
	def val = pop_Value(tv);
	setLocal(tv, index, val);
	push_Value(tv, val);
}
def GLOBAL_GET() {
	def index = imm_readULEB32();
	def tv = m_getGlobalType(index);
	def val = getGlobal(tv, index);
	push_Value(tv, val);
}
def GLOBAL_SET() {
	def index = imm_readULEB32();
	def tv = m_getGlobalType(index);
	def val = pop_Value(tv);
	setGlobal(tv, index, val);
}
def TABLE_GET() {
	def table_index = imm_readULEB32();
	def cond = m_isTable64(table_index);
	if (cond) {
		def index = pop_u64();
		def val = mach_readTable64(table_index, index);
		push_Object(val);
	} else {
		def index = pop_u32();
		def val = mach_readTable32(table_index, index);
		push_Object(val);
	}
}
def TABLE_SET() {
	def table_index = imm_readULEB32();
	def cond = m_isTable64(table_index);
	if (cond) {
		def val = pop_Object();
		def index = pop_u64();
		mach_writeTable64(table_index, index, val);
	} else {
		def val = pop_Object();
		def index = pop_u32();
		mach_writeTable32(table_index, index, val);
	}
}
def CALL() {
	def index = imm_readULEB32();
	def sig = m_getFuncSignature(index);
	def target = i_getFunction(index);
	doCall(sig, target);
}
def CALL_INDIRECT() {
	def sidetable_entry_bytes = get_st_entry(STEntry_Is64.size);
	def sidetable_entry = Ref<STEntry_Is64>.of(sidetable_entry_bytes);
	def sig_index = imm_readULEB32();
	def table_index = imm_readULEB32();
	def sig = m_getSignature(sig_index);
	if (sidetable_entry.is64) {
		def func_index = pop_u64();
		def target = i_getTableFunction64(table_index, sig, func_index);
		doCall(sig, target);
	} else {
		def func_index = pop_u32();
		def target = i_getTableFunction32(table_index, sig, func_index);
		doCall(sig, target);
	}
}
def RETURN_CALL() {
	def index = imm_readULEB32();
	def sig = m_getFuncSignature(index);
	def target = i_getFunction(index);
	doReturnCall(sig, target);
}
def DROP() {
	def tv = f_getTopOfStackType();
	pop_Value(tv);
}
def SELECT() {
	def c = pop_u32();
	def tv = f_getTopOfStackType();
	def b = pop_Value(tv);
	def a = pop_Value(tv);
	if (u32.!=(c, 0)) {
		push_Value(tv, a);
	} else {
		push_Value(tv, b);
	}
}
def I32_CONST() {
	def x = imm_readILEB32();
	push_u32(x);
}
def I32_ADD() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(u32.+(a, b));
}
def I32_SUB() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(u32.-(a, b));
}
def I32_MUL() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(u32.*(a, b));
}
def I32_DIV_S() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.==(b, 0)) {
		trapDivideByZero();
	} else {
		def cond = bool.&&(u32.==(b, u32.view(-1)), u32.==(a, u32.view(-2_147_483_648)));
		if (cond) {
			trapDivideUnrepresentable();
		} else {
			push_u32(U32_div_s(a, b));
		}
	}
}
def I32_DIV_U() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.==(b, 0)) {
		trapDivideByZero();
	} else {
		push_u32(u32./(a, b));
	}
}
def I32_EQZ() {
	def a = pop_u32();
	if (u32.==(a, 0)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_EQ() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.==(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_NE() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.!=(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_LT_U() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.<(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_LT_S() {
	def b = pop_u32();
	def a = pop_u32();
	if (U32_lt_s(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_LE_S() {
	def b = pop_u32();
	def a = pop_u32();
	if (U32_le_s(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_GT_U() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.>(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_LE_U() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.<=(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_GT_S() {
	def b = pop_u32();
	def a = pop_u32();
	if (U32_gt_s(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_GE_U() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.>=(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_GE_S() {
	def b = pop_u32();
	def a = pop_u32();
	if (U32_ge_s(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_AND() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(u32.&(a, b));
}
def I32_OR() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(u32.|(a, b));
}
def I32_XOR() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(u32.^(a, b));
}
def I32_SHL() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_shl(a, b));
}
def I32_SHR_U() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_shr_u(a, b));
}
def I32_SHR_S() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_shr_s(a, b));
}
def I32_ROTL() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_rotl(a, b));
}
def I32_ROTR() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_rotr(a, b));
}
def I32_CLZ() {
	def a = pop_u32();
	push_u32(U32_clz(a));
}
def I32_CTZ() {
	def a = pop_u32();
	push_u32(U32_ctz(a));
}
def I32_POPCNT() {
	def a = pop_u32();
	push_u32(U32_popcnt(a));
}
def I32_REM_S() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.==(b, 0)) {
		trapDivideByZero();
	} else {
		push_u32(U32_rem_s(a, b));
	}
}
def I32_REM_U() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.==(b, 0)) {
		trapDivideByZero();
	} else {
		push_u32(U32_rem_u(a, b));
	}
}
def I32_EXTEND8_S() {
	def a = pop_u32();
	def r = U32_extend8_s(a);
	push_u32(r);
}
def I32_EXTEND16_S() {
	def a = pop_u32();
	def r = U32_extend16_s(a);
	push_u32(r);
}
def I64_CONST() {
	def x = imm_readILEB64();
	push_u64(x);
}
def I64_ADD() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(u64.+(a, b));
}
def I64_SUB() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(u64.-(a, b));
}
def I64_MUL() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(u64.*(a, b));
}
def I64_DIV_S() {
	def b = pop_u64();
	def a = pop_u64();
	if (u64.==(b, 0)) {
		trapDivideByZero();
	} else {
		def cond = bool.&&(u64.==(b, u64.view(-1)), u64.==(a, u64.view(-9223372036854775808L)));
		if (cond) {
			trapDivideUnrepresentable();
		} else {
			push_u64(U64_div_s(a, b));
		}
	}
}
def I64_DIV_U() {
	def b = pop_u64();
	def a = pop_u64();
	if (u64.==(b, 0)) {
		trapDivideByZero();
	} else {
		push_u64(u64./(a, b));
	}
}
def I64_REM_S() {
	def b = pop_u64();
	def a = pop_u64();
	if (u64.==(b, 0)) {
		trapDivideByZero();
	} else {
		push_u64(U64_rem_s(a, b));
	}
}
def I64_REM_U() {
	def b = pop_u64();
	def a = pop_u64();
	if (u64.==(b, 0)) {
		trapDivideByZero();
	} else {
		push_u64(U64_rem_u(a, b));
	}
}
def I64_AND() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(u64.&(a, b));
}
def I64_OR() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(u64.|(a, b));
}
def I64_XOR() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(u64.^(a, b));
}
def I64_SHL() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_shl(a, b));
}
def I64_SHR_U() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_shr_u(a, b));
}
def I64_SHR_S() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_shr_s(a, b));
}
def I64_ROTL() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_rotl(a, b));
}
def I64_ROTR() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_rotr(a, b));
}
def I64_CLZ() {
	def a = pop_u64();
	push_u64(U64_clz(a));
}
def I64_CTZ() {
	def a = pop_u64();
	push_u64(U64_ctz(a));
}
def I64_POPCNT() {
	def a = pop_u64();
	push_u64(U64_popcnt(a));
}
def I64_EQZ() {
	def a = pop_u64();
	if (u64.==(a, 0)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I64_EQ() {
	def b = pop_u64();
	def a = pop_u64();
	if (u64.==(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I64_NE() {
	def b = pop_u64();
	def a = pop_u64();
	if (u64.!=(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I64_LT_S() {
	def b = pop_u64();
	def a = pop_u64();
	if (U64_lt_s(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I64_LT_U() {
	def b = pop_u64();
	def a = pop_u64();
	if (u64.<(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I64_LE_S() {
	def b = pop_u64();
	def a = pop_u64();
	if (U64_le_s(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I64_LE_U() {
	def b = pop_u64();
	def a = pop_u64();
	if (u64.<=(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I64_GT_S() {
	def b = pop_u64();
	def a = pop_u64();
	if (U64_gt_s(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I64_GT_U() {
	def b = pop_u64();
	def a = pop_u64();
	if (u64.>(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I64_GE_S() {
	def b = pop_u64();
	def a = pop_u64();
	if (U64_ge_s(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I64_GE_U() {
	def b = pop_u64();
	def a = pop_u64();
	if (u64.>=(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I64_EXTEND8_S() {
	def a = pop_u64();
	def r = U64_extend8_s(a);
	push_u64(r);
}
def I64_EXTEND16_S() {
	def a = pop_u64();
	def r = U64_extend16_s(a);
	push_u64(r);
}
def I64_EXTEND32_S() {
	def a = pop_u64();
	def r = U64_extend32_s(a);
	push_u64(r);
}
def F32_CONST() {
	def x = imm_readULEB32();
	def arg = f32_reinterpret_u32(x);
	push_f32(arg);
}
def F32_ADD() {
	def b = pop_f32();
	def a = pop_f32();
	push_f32(float.+(a, b));
}
def F32_SUB() {
	def b = pop_f32();
	def a = pop_f32();
	push_f32(float.-(a, b));
}
def F32_MUL() {
	def b = pop_f32();
	def a = pop_f32();
	push_f32(float.*(a, b));
}
def F32_DIV() {
	def b = pop_f32();
	def a = pop_f32();
	if (float.==(b, 0.0f)) {
		trapDivideByZero();
	} else {
		push_f32(float./(a, b));
	}
}
def F32_SQRT() {
	def a = pop_f32();
	push_f32(float.sqrt(a));
}
def F32_EQ() {
	def b = pop_f32();
	def a = pop_f32();
	if (float.==(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def F32_NE() {
	def b = pop_f32();
	def a = pop_f32();
	if (float.!=(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def F32_LT() {
	def b = pop_f32();
	def a = pop_f32();
	if (float.<(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def F32_LE() {
	def b = pop_f32();
	def a = pop_f32();
	if (float.<=(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def F32_GT() {
	def b = pop_f32();
	def a = pop_f32();
	if (float.>(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def BR() {
	def sidetable_entry_bytes = get_st_entry(STEntry_Label.size);
	def sidetable_entry = Ref<STEntry_Label>.of(sidetable_entry_bytes);
	def depth = imm_readULEB32();
	doBranch(sidetable_entry.label);
}
def BR_IF() {
	def sidetable_entry_bytes = get_st_entry(STEntry_Label.size);
	def sidetable_entry = Ref<STEntry_Label>.of(sidetable_entry_bytes);
	def depth = imm_readULEB32();
	def cond = pop_u32();
	if (u32.!=(cond, 0)) {
		doBranch(sidetable_entry.label);
	} else {
		doFallthru();
	}
}
def BR_TABLE() {
	def sidetable_entry_bytes = get_st_entry(STEntry_Labels.size);
	def sidetable_entry = Ref<STEntry_Labels>.of(sidetable_entry_bytes);
	def key = pop_u32();
	doSwitch(sidetable_entry.labels, key);
}
def BLOCK() {
	def bt = imm_readBlockType();
	doBlock(bt);
}
def LOOP() {
	def bt = imm_readBlockType();
	doLoop(bt);
}
def TRY() {
	def bt = imm_readBlockType();
	doTry(bt);
}
def IF() {
	def sidetable_entry_bytes = get_st_entry(STEntry_Label.size);
	def sidetable_entry = Ref<STEntry_Label>.of(sidetable_entry_bytes);
	def bt = imm_readBlockType();
	def cond = pop_u32();
	if (u32.==(cond, 0)) {
		doBranch(sidetable_entry.label);
	} else {
		doFallthru();
	}
}
def ELSE() {
	def sidetable_entry_bytes = get_st_entry(STEntry_Label.size);
	def sidetable_entry = Ref<STEntry_Label>.of(sidetable_entry_bytes);
	doBranch(sidetable_entry.label);
}
def END() {
	doEnd();
	if (f_isAtEnd()) {
		doReturn();
	}
}
def RETURN() {
	doReturn();
}
def REF_NULL() {
	def idx = imm_readULEB32();
	def arg = object_Null();
	push_Object(arg);
}
def REF_IS_NULL() {
	def obj = pop_Object();
	def cond = object_isNull(obj);
	if (cond) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def REF_AS_NON_NULL() {
	def obj = pop_Object();
	def cond = object_isNull(obj);
	if (cond) {
		trapNull();
	}
	push_Object(obj);
}
def STRUCT_NEW() {
	def struct_idx = imm_readULEB32();
	def sig = m_getSignature(struct_idx);
	push_Object(object_New(sig));
}
def STRUCT_GET() {
	def sidetable_entry_bytes = get_st_entry(STEntry_KindOffset.size);
	def sidetable_entry = Ref<STEntry_KindOffset>.of(sidetable_entry_bytes);
	def struct_index = imm_readULEB32();
	def field_index = imm_readULEB32();
	def obj = pop_Object();
	def cond = object_isNull(obj);
	if (cond) {
		trapNull();
	}
	match (sidetable_entry.kind) {
		U32 => {
			def arg = mach_readStructField_u32(obj, sidetable_entry.offset);
			push_u32(arg);
		}
		U64 => {
			def arg1 = mach_readStructField_u64(obj, sidetable_entry.offset);
			push_u64(arg1);
		}
		F32 => {
			def arg2 = mach_readStructField_f32(obj, sidetable_entry.offset);
			push_f32(arg2);
		}
		F64 => {
			def arg3 = mach_readStructField_f64(obj, sidetable_entry.offset);
			push_f64(arg3);
		}
		V128 => {
			def arg4 = mach_readStructField_v128(obj, sidetable_entry.offset);
			push_v128(arg4);
		}
		REF => {
			def arg5 = mach_readStructField_Object(obj, sidetable_entry.offset);
			push_Object(arg5);
		}
		_ => trapUnreachable();
	}
}
def STRUCT_GET_S() {
	def sidetable_entry_bytes = get_st_entry(STEntry_KindOffset.size);
	def sidetable_entry = Ref<STEntry_KindOffset>.of(sidetable_entry_bytes);
	def struct_index = imm_readULEB32();
	def field_index = imm_readULEB32();
	def obj = pop_Object();
	def cond = object_isNull(obj);
	if (cond) {
		trapNull();
	}
	match (sidetable_entry.kind) {
		U8 => {
			def arg = mach_readStructField_u8(obj, sidetable_entry.offset);
			push_u32(u32.view(arg));
		}
		U16 => {
			def arg1 = mach_readStructField_u16(obj, sidetable_entry.offset);
			push_u32(u32.view(arg1));
		}
		_ => trapUnreachable();
	}
}
def STRUCT_GET_U() {
	def sidetable_entry_bytes = get_st_entry(STEntry_KindOffset.size);
	def sidetable_entry = Ref<STEntry_KindOffset>.of(sidetable_entry_bytes);
	def struct_index = imm_readULEB32();
	def field_index = imm_readULEB32();
	def obj = pop_Object();
	def cond = object_isNull(obj);
	if (cond) {
		trapNull();
	}
	match (sidetable_entry.kind) {
		U8 => {
			def arg = mach_readStructField_u8(obj, sidetable_entry.offset);
			push_u32(u32.view(arg));
		}
		U16 => {
			def arg1 = mach_readStructField_u16(obj, sidetable_entry.offset);
			push_u32(u32.view(arg1));
		}
		_ => trapUnreachable();
	}
}
def I32_LOAD() {
	def flags = imm_readU8();
	var memindex = 0u;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u32(memindex, index, offset);
		push_u32(val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		def val = mach_readMemory32_u32(memindex, index, offset);
		push_u32(val);
	}
}
def I32_LOAD8_U() {
	def flags = imm_readU8();
	var memindex = 0u;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u8(memindex, index, offset);
		push_u32(val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		def val = mach_readMemory32_u8(memindex, index, offset);
		push_u32(val);
	}
}
def I32_LOAD16_S() {
	def flags = imm_readU8();
	var memindex = 0u;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u16(memindex, index, offset);
		push_u32(val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		def val = mach_readMemory32_u16(memindex, index, offset);
		push_u32(val);
	}
}
def I64_LOAD() {
	def flags = imm_readU8();
	var memindex = 0u;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u64(memindex, index, offset);
		push_u64(val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		def val = mach_readMemory32_u64(memindex, index, offset);
		push_u64(val);
	}
}
def F32_LOAD() {
	def flags = imm_readU8();
	var memindex = 0u;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_f32(memindex, index, offset);
		push_f32(val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		def val = mach_readMemory32_f32(memindex, index, offset);
		push_f32(val);
	}
}
def F64_LOAD() {
	def flags = imm_readU8();
	var memindex = 0u;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_f64(memindex, index, offset);
		push_f64(val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		def val = mach_readMemory32_f64(memindex, index, offset);
		push_f64(val);
	}
}
def I32_STORE() {
	def flags = imm_readU8();
	var memindex = 0u;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	}
	def val = pop_u32();
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u32(memindex, index, offset, val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		mach_writeMemory32_u32(memindex, index, offset, val);
	}
}
def I32_STORE8() {
	def flags = imm_readU8();
	var memindex = 0u;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	}
	def val = pop_u32();
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u8(memindex, index, offset, val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		mach_writeMemory32_u8(memindex, index, offset, val);
	}
}
def I32_STORE16() {
	def flags = imm_readU8();
	var memindex = 0u;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	}
	def val = pop_u32();
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u16(memindex, index, offset, val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		mach_writeMemory32_u16(memindex, index, offset, val);
	}
}
def I64_STORE() {
	def flags = imm_readU8();
	var memindex = 0u;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	}
	def val = pop_u64();
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u64(memindex, index, offset, val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		mach_writeMemory32_u64(memindex, index, offset, val);
	}
}
def F32_STORE() {
	def flags = imm_readU8();
	var memindex = 0u;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	}
	def val = pop_f32();
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
	}
}
def F64_STORE() {
	def flags = imm_readU8();
	var memindex = 0u;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	}
	def val = pop_f64();
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_f64(memindex, index, offset, val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		mach_writeMemory32_f64(memindex, index, offset, val);
	}
}
def build_dispatch_table() -> Array<void -> void> {
  DISPATCH_TABLE = Array.new(0xE5 + 1);
  for (i < 0xE5 + 1) DISPATCH_TABLE[i] = null;
  DISPATCH_TABLE[Opcode.UNREACHABLE.tag] = UNREACHABLE;
  DISPATCH_TABLE[Opcode.NOP.tag] = NOP;
  DISPATCH_TABLE[Opcode.LOCAL_GET.tag] = LOCAL_GET;
  DISPATCH_TABLE[Opcode.LOCAL_SET.tag] = LOCAL_SET;
  DISPATCH_TABLE[Opcode.LOCAL_TEE.tag] = LOCAL_TEE;
  DISPATCH_TABLE[Opcode.GLOBAL_GET.tag] = GLOBAL_GET;
  DISPATCH_TABLE[Opcode.GLOBAL_SET.tag] = GLOBAL_SET;
  DISPATCH_TABLE[Opcode.TABLE_GET.tag] = TABLE_GET;
  DISPATCH_TABLE[Opcode.TABLE_SET.tag] = TABLE_SET;
  DISPATCH_TABLE[Opcode.CALL.tag] = CALL;
  DISPATCH_TABLE[Opcode.CALL_INDIRECT.tag] = CALL_INDIRECT;
  DISPATCH_TABLE[Opcode.RETURN_CALL.tag] = RETURN_CALL;
  DISPATCH_TABLE[Opcode.DROP.tag] = DROP;
  DISPATCH_TABLE[Opcode.SELECT.tag] = SELECT;
  DISPATCH_TABLE[Opcode.I32_CONST.tag] = I32_CONST;
  DISPATCH_TABLE[Opcode.I32_ADD.tag] = I32_ADD;
  DISPATCH_TABLE[Opcode.I32_SUB.tag] = I32_SUB;
  DISPATCH_TABLE[Opcode.I32_MUL.tag] = I32_MUL;
  DISPATCH_TABLE[Opcode.I32_DIV_S.tag] = I32_DIV_S;
  DISPATCH_TABLE[Opcode.I32_DIV_U.tag] = I32_DIV_U;
  DISPATCH_TABLE[Opcode.I32_EQZ.tag] = I32_EQZ;
  DISPATCH_TABLE[Opcode.I32_EQ.tag] = I32_EQ;
  DISPATCH_TABLE[Opcode.I32_NE.tag] = I32_NE;
  DISPATCH_TABLE[Opcode.I32_LT_U.tag] = I32_LT_U;
  DISPATCH_TABLE[Opcode.I32_LT_S.tag] = I32_LT_S;
  DISPATCH_TABLE[Opcode.I32_LE_S.tag] = I32_LE_S;
  DISPATCH_TABLE[Opcode.I32_GT_U.tag] = I32_GT_U;
  DISPATCH_TABLE[Opcode.I32_LE_U.tag] = I32_LE_U;
  DISPATCH_TABLE[Opcode.I32_GT_S.tag] = I32_GT_S;
  DISPATCH_TABLE[Opcode.I32_GE_U.tag] = I32_GE_U;
  DISPATCH_TABLE[Opcode.I32_GE_S.tag] = I32_GE_S;
  DISPATCH_TABLE[Opcode.I32_AND.tag] = I32_AND;
  DISPATCH_TABLE[Opcode.I32_OR.tag] = I32_OR;
  DISPATCH_TABLE[Opcode.I32_XOR.tag] = I32_XOR;
  DISPATCH_TABLE[Opcode.I32_SHL.tag] = I32_SHL;
  DISPATCH_TABLE[Opcode.I32_SHR_U.tag] = I32_SHR_U;
  DISPATCH_TABLE[Opcode.I32_SHR_S.tag] = I32_SHR_S;
  DISPATCH_TABLE[Opcode.I32_ROTL.tag] = I32_ROTL;
  DISPATCH_TABLE[Opcode.I32_ROTR.tag] = I32_ROTR;
  DISPATCH_TABLE[Opcode.I32_CLZ.tag] = I32_CLZ;
  DISPATCH_TABLE[Opcode.I32_CTZ.tag] = I32_CTZ;
  DISPATCH_TABLE[Opcode.I32_POPCNT.tag] = I32_POPCNT;
  DISPATCH_TABLE[Opcode.I32_REM_S.tag] = I32_REM_S;
  DISPATCH_TABLE[Opcode.I32_REM_U.tag] = I32_REM_U;
  DISPATCH_TABLE[Opcode.I32_EXTEND8_S.tag] = I32_EXTEND8_S;
  DISPATCH_TABLE[Opcode.I32_EXTEND16_S.tag] = I32_EXTEND16_S;
  DISPATCH_TABLE[Opcode.I64_CONST.tag] = I64_CONST;
  DISPATCH_TABLE[Opcode.I64_ADD.tag] = I64_ADD;
  DISPATCH_TABLE[Opcode.I64_SUB.tag] = I64_SUB;
  DISPATCH_TABLE[Opcode.I64_MUL.tag] = I64_MUL;
  DISPATCH_TABLE[Opcode.I64_DIV_S.tag] = I64_DIV_S;
  DISPATCH_TABLE[Opcode.I64_DIV_U.tag] = I64_DIV_U;
  DISPATCH_TABLE[Opcode.I64_REM_S.tag] = I64_REM_S;
  DISPATCH_TABLE[Opcode.I64_REM_U.tag] = I64_REM_U;
  DISPATCH_TABLE[Opcode.I64_AND.tag] = I64_AND;
  DISPATCH_TABLE[Opcode.I64_OR.tag] = I64_OR;
  DISPATCH_TABLE[Opcode.I64_XOR.tag] = I64_XOR;
  DISPATCH_TABLE[Opcode.I64_SHL.tag] = I64_SHL;
  DISPATCH_TABLE[Opcode.I64_SHR_U.tag] = I64_SHR_U;
  DISPATCH_TABLE[Opcode.I64_SHR_S.tag] = I64_SHR_S;
  DISPATCH_TABLE[Opcode.I64_ROTL.tag] = I64_ROTL;
  DISPATCH_TABLE[Opcode.I64_ROTR.tag] = I64_ROTR;
  DISPATCH_TABLE[Opcode.I64_CLZ.tag] = I64_CLZ;
  DISPATCH_TABLE[Opcode.I64_CTZ.tag] = I64_CTZ;
  DISPATCH_TABLE[Opcode.I64_POPCNT.tag] = I64_POPCNT;
  DISPATCH_TABLE[Opcode.I64_EQZ.tag] = I64_EQZ;
  DISPATCH_TABLE[Opcode.I64_EQ.tag] = I64_EQ;
  DISPATCH_TABLE[Opcode.I64_NE.tag] = I64_NE;
  DISPATCH_TABLE[Opcode.I64_LT_S.tag] = I64_LT_S;
  DISPATCH_TABLE[Opcode.I64_LT_U.tag] = I64_LT_U;
  DISPATCH_TABLE[Opcode.I64_LE_S.tag] = I64_LE_S;
  DISPATCH_TABLE[Opcode.I64_LE_U.tag] = I64_LE_U;
  DISPATCH_TABLE[Opcode.I64_GT_S.tag] = I64_GT_S;
  DISPATCH_TABLE[Opcode.I64_GT_U.tag] = I64_GT_U;
  DISPATCH_TABLE[Opcode.I64_GE_S.tag] = I64_GE_S;
  DISPATCH_TABLE[Opcode.I64_GE_U.tag] = I64_GE_U;
  DISPATCH_TABLE[Opcode.I64_EXTEND8_S.tag] = I64_EXTEND8_S;
  DISPATCH_TABLE[Opcode.I64_EXTEND16_S.tag] = I64_EXTEND16_S;
  DISPATCH_TABLE[Opcode.I64_EXTEND32_S.tag] = I64_EXTEND32_S;
  DISPATCH_TABLE[Opcode.F32_CONST.tag] = F32_CONST;
  DISPATCH_TABLE[Opcode.F32_ADD.tag] = F32_ADD;
  DISPATCH_TABLE[Opcode.F32_SUB.tag] = F32_SUB;
  DISPATCH_TABLE[Opcode.F32_MUL.tag] = F32_MUL;
  DISPATCH_TABLE[Opcode.F32_DIV.tag] = F32_DIV;
  DISPATCH_TABLE[Opcode.F32_SQRT.tag] = F32_SQRT;
  DISPATCH_TABLE[Opcode.F32_EQ.tag] = F32_EQ;
  DISPATCH_TABLE[Opcode.F32_NE.tag] = F32_NE;
  DISPATCH_TABLE[Opcode.F32_LT.tag] = F32_LT;
  DISPATCH_TABLE[Opcode.F32_LE.tag] = F32_LE;
  DISPATCH_TABLE[Opcode.F32_GT.tag] = F32_GT;
  DISPATCH_TABLE[Opcode.BR.tag] = BR;
  DISPATCH_TABLE[Opcode.BR_IF.tag] = BR_IF;
  DISPATCH_TABLE[Opcode.BR_TABLE.tag] = BR_TABLE;
  DISPATCH_TABLE[Opcode.BLOCK.tag] = BLOCK;
  DISPATCH_TABLE[Opcode.LOOP.tag] = LOOP;
  DISPATCH_TABLE[Opcode.TRY.tag] = TRY;
  DISPATCH_TABLE[Opcode.IF.tag] = IF;
  DISPATCH_TABLE[Opcode.ELSE.tag] = ELSE;
  DISPATCH_TABLE[Opcode.END.tag] = END;
  DISPATCH_TABLE[Opcode.RETURN.tag] = RETURN;
  DISPATCH_TABLE[Opcode.REF_NULL.tag] = REF_NULL;
  DISPATCH_TABLE[Opcode.REF_IS_NULL.tag] = REF_IS_NULL;
  DISPATCH_TABLE[Opcode.REF_AS_NON_NULL.tag] = REF_AS_NON_NULL;
  DISPATCH_TABLE[Opcode.STRUCT_NEW.tag] = STRUCT_NEW;
  DISPATCH_TABLE[Opcode.STRUCT_GET.tag] = STRUCT_GET;
  DISPATCH_TABLE[Opcode.STRUCT_GET_S.tag] = STRUCT_GET_S;
  DISPATCH_TABLE[Opcode.STRUCT_GET_U.tag] = STRUCT_GET_U;
  DISPATCH_TABLE[Opcode.I32_LOAD.tag] = I32_LOAD;
  DISPATCH_TABLE[Opcode.I32_LOAD8_U.tag] = I32_LOAD8_U;
  DISPATCH_TABLE[Opcode.I32_LOAD16_S.tag] = I32_LOAD16_S;
  DISPATCH_TABLE[Opcode.I64_LOAD.tag] = I64_LOAD;
  DISPATCH_TABLE[Opcode.F32_LOAD.tag] = F32_LOAD;
  DISPATCH_TABLE[Opcode.F64_LOAD.tag] = F64_LOAD;
  DISPATCH_TABLE[Opcode.I32_STORE.tag] = I32_STORE;
  DISPATCH_TABLE[Opcode.I32_STORE8.tag] = I32_STORE8;
  DISPATCH_TABLE[Opcode.I32_STORE16.tag] = I32_STORE16;
  DISPATCH_TABLE[Opcode.I64_STORE.tag] = I64_STORE;
  DISPATCH_TABLE[Opcode.F32_STORE.tag] = F32_STORE;
  DISPATCH_TABLE[Opcode.F64_STORE.tag] = F64_STORE;
  return DISPATCH_TABLE;
}
}
