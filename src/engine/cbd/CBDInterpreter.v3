// GENERATED BY InterpreterGen.v3
class CBDWasmStack(cbd_interpreter: CBDV3Interpreter) extends WasmStack {
    def it = cbd_interpreter.it;
    def state() -> StackState => it.state();
    def reset(func: Function) -> this { it.reset(func); }
    def bind(args: Range<Value>) -> this { it.bind(args); }
    def resume() -> Result {
        it.thrown = null;
        it.goto_stack = null;
        if (it.frame.pc == 0) it.codeptr.iterate_local_codes(it.pushLocals);
        def tags = it.frame.func.decl.frame_var_tags;
        if (tags != null) for (t in tags) it.values.push(it.tagToValue(t));

        while (it.state_ == StackState.RUNNING && it.frame != null) {
            it.frame.pc = it.codeptr.pos;
            def opcode = it.codeptr.read_opcode();
            cbd_interpreter.DISPATCH_TABLE[opcode.tag]();
        }

        // TODO: match on result
        def top = it.values.top;
        def vals = Ranges.dup(it.values.peekn(it.return_arity));
        it.clear();
        return Result.Value(vals);
    }
    // def where = it.where;
    // def caller = it.caller;
    // def clear = it.clear;
	// def tryHandleSuspension = it.tryHandleSuspension;
	// def tryHandleSwitch = it.tryHandleSwitch;
}

class CBDV3Interpreter(it: V3Interpreter) {
    // can't extend V3Interpreter directly bc some intrinsics overlap with method names

    def HAS_MEM_INDEX = 0x40u8;
    var DISPATCH_TABLE: Array<void -> void>;

    def init_module(module: Module) {
        DISPATCH_TABLE = build_dispatch_table();
        Validator.init(module, []);
    }

    // for InterpreterMain
    def init(instance: Instance, args: Array<int>) {
        def module = instance.module;
        DISPATCH_TABLE = build_dispatch_table();

        var main_idx = -1;
        for (i < module.exports.length) {
            if (Strings.equal(module.exports[i].0, "main")) main_idx = FuncDecl.!(module.exports[i].1).func_index;
        }

        Validator.init(module, args);
        for (i < module.functions.length) {
            def fn = CBDFunction.new(module.functions[i]);
            Validator.init_function(fn.code, fn.args.copy(), fn.locals.copy(), fn.rets.copy());
            Validator.dispatch();
            fn.sidetable = Validator.build_sidetable();
            System.puts("validated ");
            System.puti(i);
            System.ln();
        }

        it.reset(instance.functions[main_idx]);
    }

    def dispatch() {
        it.codeptr.iterate_local_codes(it.pushLocals);
        def tags = it.frame.func.decl.frame_var_tags;
        if (tags != null) for (t in tags) it.values.push(it.tagToValue(t));

        while (it.frame != null && it.codeptr.available() > 0) {
            it.frame.pc = it.codeptr.pos;
            def opcode = it.codeptr.read_opcode();
            // System.puts(opcode.mnemonic); System.ln();
            DISPATCH_TABLE[opcode.tag]();
        }
    }

    def get_stack() => it.values;

    def module() => it.frame.func.instance.module;
    def functions() => it.frame.func.instance.module;

    def imm_readULEB32() -> u32 => it.codeptr.read_uleb32();
    def imm_readULEB64() -> u64 => it.codeptr.read_uleb64();

    def imm_readILEB32() -> u32 => u32.view(it.codeptr.read_sleb32());
    def imm_readILEB64() -> u64 => u32.view(it.codeptr.read_sleb64());

    def imm_readU8() -> u8 => it.codeptr.read1();

    def imm_readBlockType() -> (Array<ValueType>, Array<ValueType>) {
        def bt = it.codeptr.read_BlockTypeCode();
        return bt.toAbstractBlockType(module());
    }

    def pop_u32: void -> u32 = it.popu;
    def pop_u64: void -> u64 = it.popw;
    def pop_f32: void -> float = it.popf;
    def pop_f64: void -> double = it.popd;
    def pop_v128() -> v128;
    def pop_Object: void -> Object = it.popObject;
    def pop_Value(tv: ()) -> Value => it.pop();

    def push_u32: u32 -> void = it.pushu;
    def push_u64: u64 -> void = it.pushw;
    def push_f32: float -> void = it.pushf;
    def push_f64: double -> void = it.pushd;
    def push_v128(v: v128);
    def push_Object(v: Object) => it.values.push(Value.Ref(v));
    def push_Value(tv: (), v: Value) => it.values.push(v);

    // Local variables.
    def getLocal(tv: (), index: u32) -> Value {
        return it.values.elems[it.frame.fp + int.view(index)];
    }
    def setLocal(tv: (), index: u32, v: Value) {
        it.values.elems[it.frame.fp + int.view(index)] = v;
    }

    // Global variables.
    def getGlobal(tv: (), index: u32) -> Value {
        // XXX: should use Runtime.GLOBAL_GET?
        return it.frame.func.instance.globals[int.view(index)].get();
    }
    def setGlobal(tv: (), index: u32, v: Value) {
        it.frame.func.instance.globals[int.view(index)].set(v);
    }

    // XXX: is a label always a SidetableBrEntry?
    def f_getLabel(depth: u32) -> SidetableBrEntry {
        def stp = it.frame.stp, sidetable = it.frame.func.decl.sidetable;
        return sidetable.getBrEntry(stp);
    }

    def f_getLocalType(index: u32) -> () {
        return ();
    }

    def f_getTopOfStackType() -> () {
        return ();
    }

    // Module context.
    def m_getGlobalType(index: u32) -> () {
        return ();
    }
    def m_getFieldKind(struct_index: u32, field_index: u32) -> FieldKind {
        def ht = module().heaptypes[int.view(struct_index)];
        def decl = StructDecl.!(ht);
        def st = decl.field_types[field_index];
        match (st.valtype) {
            BOTTOM => return FieldKind.REF;
            I32 => return FieldKind.U32;
            I64 => return FieldKind.U64;
            F32 => return FieldKind.F32;
            F64 => return FieldKind.F64;
            V128 => return FieldKind.V128;
            Host => return FieldKind.REF;
            Ref => return FieldKind.REF;
        }
    }
    def m_getFieldOffset(struct_index: u32, field_index: u32) -> FieldOffset {
        return FieldOffset(u32.!(field_index)); // XXX?
    }
    def m_isMemory64(memory_index: u32) -> bool => false; // TODO mem64
    def m_isTable64(memory_index: u32) -> bool => false;
    def m_getFuncSignature(func_index: u32) -> SigDecl {
        return null; // already in CBDFunction, TODO: refactor
    }
    def m_getSignature(sig_index: u32) -> HeapTypeDecl {
        return module().heaptypes[int.view(sig_index)];
    }

    // Instance context.
    def i_getTableFunction64(table_index: u32, sig: HeapTypeDecl, func_index: u64) -> Function;
    def i_getTableFunction32(table_index: u32, sig: HeapTypeDecl, func_index: u32) -> Function;
    def i_getFunction(func_index: u32) -> Function {
        return it.frame.func.instance.functions[int.view(func_index)];
    }

    // Control flow.
    def doCall(sig: Decl, target: Function) {
        it.doCallFunction(target);
        it.codeptr.iterate_local_codes(it.pushLocals);
        def tags = it.frame.func.decl.frame_var_tags;
        if (tags != null) for (t in tags) it.values.push(it.tagToValue(t));
    }
    def doReturnCall(sig: Decl, target: Function) {
        it.prepareReturnCall(SigDecl.!(sig));
        it.doCallFunction(target);
    }

    def doBranch(label: SidetableBrEntry) {
        // doCtlXfer
        it.codeptr.at(it.frame.pc + label.dpc);
        it.frame.stp += label.dstp;
        if (label.popcount > 0) {
            if (label.valcount > 0) it.copyVals(label.valcount, it.values.top - int.!(label.popcount + label.valcount));
            else it.values.top -= label.popcount;
        }
    }

    def doFallthru() {
        it.frame.stp += 4;
    }

    // Machine intrinsics.
    def mach_readStructField_u8(obj: Object, offset: FieldOffset) -> u8;
    def mach_readStructField_u16(obj: Object, offset: FieldOffset) -> u16;
    def mach_readStructField_u32(obj: Object, offset: FieldOffset) -> u32 {
        def s = HeapStruct.!(obj);
        return Values.unbox_u(s.vals[offset.offset]);
    }
    def mach_readStructField_u64(obj: Object, offset: FieldOffset) -> u64;
    def mach_readStructField_f32(obj: Object, offset: FieldOffset) -> float;
    def mach_readStructField_f64(obj: Object, offset: FieldOffset) -> double;
    def mach_readStructField_v128(obj: Object, offset: FieldOffset) -> v128;
    def mach_readStructField_Object(obj: Object, offset: FieldOffset) -> Object {
        def s = HeapStruct.!(obj);
        def r = Value.Ref.!(s.vals[offset.offset]);
        return r.val;
    }

    // XXX: should Object always be HeapObject?
    def object_Null() -> Object => null;
    def object_isNull(o: Object) => o == null;
    // should see how much we can leverage Runtime.v3
    def object_New(sig: HeapTypeDecl) -> Object {
        def decl = StructDecl.!(sig);
        def fields = Array<Value>.new(decl.field_types.length);
        for (i = fields.length - 1; i >= 0; i -= 1) {
            fields[i] = pop_Value(());
        }
        return HeapStruct.new(decl, fields);
    }

    // XXX: should look more closely at what v3interpreter does
    def doRead32<R, T>(
        memory_index: u32, index: u32, offset: u32, read: (Memory, u32, u32) -> MaybeTrap<R>, view: R -> T
    ) -> T {
        def memory = it.frame.func.instance.memories[int.view(memory_index)];
        def read_res = read(memory, u32.view(offset), u32.view(index));
        if (read_res.trapped()) trapMem();
        return view(read_res.result);
    }


    def mach_readMemory64_u8(memory_index: u32, index: u64, offset: u64) -> u8;
    def mach_readMemory32_u8(memory_index: u32, index: u32, offset: u32) =>
        doRead32<u8, u8>(memory_index, index, offset, Memory.read_u8, u8.view);
    def mach_readMemory64_u16(memory_index: u32, index: u64, offset: u64) -> u16;
    def mach_readMemory32_u16(memory_index: u32, index: u32, offset: u32) =>
        doRead32<u16, u16>(memory_index, index, offset, Memory.read_u16, u16.view);
    def mach_readMemory64_u32(memory_index: u32, index: u64, offset: u64) -> u32;
    def mach_readMemory32_u32(memory_index: u32, index: u32, offset: u32) =>
        doRead32<u32, u32>(memory_index, index, offset, Memory.read_u32, u32.view);
    def mach_readMemory64_u64(memory_index: u32, index: u64, offset: u64) -> u64;
    def mach_readMemory32_u64(memory_index: u32, index: u32, offset: u32) =>
        doRead32<u64, u64>(memory_index, index, offset, Memory.read_u64, u64.view);
    def mach_readMemory64_f32(memory_index: u32, index: u64, offset: u64) -> float;
    def mach_readMemory32_f32(memory_index: u32, index: u32, offset: u32) =>
        doRead32<float, float>(memory_index, index, offset, Memory.read_float, fun x => x);
    def mach_readMemory64_f64(memory_index: u32, index: u64, offset: u64) -> double;
    def mach_readMemory32_f64(memory_index: u32, index: u32, offset: u32) =>
        doRead32<double, double>(memory_index, index, offset, Memory.read_double, fun x => x);

    // XXX: should look more closely at what v3interpreter does
    def doWrite32<P, T>(
        memory_index: u32, index: u32, offset: u32, val: P, write: (Memory, u32, u32, T) -> TrapReason, view: P -> T
    ) {
        def memory = it.frame.func.instance.memories[int.view(memory_index)];
        def t = write(memory, u32.view(offset), u32.view(index), view(val));
        if (t != TrapReason.NONE) trapMem();
    }
    def mach_writeMemory64_u8(memory_index: u32, index: u64, offset: u64, val: u32);
    def mach_writeMemory32_u8(memory_index: u32, index: u32, offset: u32, val: u32) =>
        doWrite32<u32, u8>(memory_index, index, offset, val, Memory.write_u8, u8.view);
    def mach_writeMemory64_u16(memory_index: u32, index: u64, offset: u64, val: u32);
    def mach_writeMemory32_u16(memory_index: u32, index: u32, offset: u32, val: u32) =>
        doWrite32<u32, u16>(memory_index, index, offset, val, Memory.write_u16, u16.view);
    def mach_writeMemory64_u32(memory_index: u32, index: u64, offset: u64, val: u32);
    def mach_writeMemory32_u32(memory_index: u32, index: u32, offset: u32, val: u32) =>
        doWrite32<u32, u32>(memory_index, index, offset, val, Memory.write_u32, u32.view);
    def mach_writeMemory64_u64(memory_index: u32, index: u64, offset: u64, val: u64);
    def mach_writeMemory32_u64(memory_index: u32, index: u32, offset: u32, val: u64) =>
        doWrite32<u64, u64>(memory_index, index, offset, val, Memory.write_u64, u64.view);

    def mach_writeMemory64_f32(memory_index: u32, index: u64, offset: u64, val: float);
    def mach_writeMemory32_f32(memory_index: u32, index: u32, offset: u32, val: float) =>
        doWrite32<float, float>(memory_index, index, offset, val, Memory.write_float, fun x => x);
    def mach_writeMemory64_f64(memory_index: u32, index: u64, offset: u64, val: double);
    def mach_writeMemory32_f64(memory_index: u32, index: u32, offset: u32, val: double) =>
        doWrite32<double, double>(memory_index, index, offset, val, Memory.write_double, fun x => x);

    def mach_readTable64(table_index: u32, index: u64) -> Object;
    def mach_readTable32(table_index: u32, index: u32) -> Object {
	def table = it.frame.func.instance.tables[int.view(table_index)];
	def elems = table.elems;
	if (index >= elems.length) {
	    trapTableOOB();
	}
	return Values.unbox(elems[index]);
    }

    def mach_writeTable64(table_index: u32, index: u64, val: Object);
    def mach_writeTable32(table_index: u32, index: u32, val: Object) {
	def table = it.frame.func.instance.tables[int.view(table_index)];
	def elems = table.elems;
	if (index >= elems.length) {
	    trapTableOOB();
	}
	table[int.view(index)] = Value.Ref(val);
    }

    // Traps.
    def invalid(); // should never occur
    def trapNull();
    def trapUnreachable();
    def trapDivideByZero();
    def trapDivideUnrepresentable();
    def trapMem();
    def trapTableOOB();

    def doBlock(bt: (Array<ValueType>, Array<ValueType>)) {
    }

    def doLoop(bt: (Array<ValueType>, Array<ValueType>)) {
    }

    def doIf(bt: (Array<ValueType>, Array<ValueType>)) -> SidetableBrEntry {
        return it.frame.func.decl.sidetable.getBrEntry(it.frame.stp);
    }

    def doElse() -> SidetableBrEntry {
        return it.frame.func.decl.sidetable.getBrEntry(it.frame.stp);
    }

    def doEnd() {
        // CBD calls doReturn if at end
    }

    def doReturn() {
        def fp = it.frame.fp;
        def sig = it.frame.func.sig;
        it.doReturn(fp, sig);
    }

    def doTry(bt: (Array<ValueType>, Array<ValueType>)) {
        return;
    }

    def f_isAtEnd() -> bool {
        return it.codeptr.available() == 0;
    }

    def f32_reinterpret_u32(i: u32) -> float;
    def f64_reinterpret_u64(i: u64) -> double;
    def u32_reinterpret_f32(f: float) -> u32;
    def u64_reinterpret_f64(f: double) -> u64;

    def u32_div_s(lhs: u32, rhs: u32) -> u32 => u32.view(i32.view(lhs) / i32.view(rhs));
    def u32_lt_s(lhs: u32, rhs: u32) -> bool => i32.view(lhs) < i32.view(rhs);
    def u32_le_s(lhs: u32, rhs: u32) -> bool => i32.view(lhs) <= i32.view(rhs);

def UNREACHABLE() {
	trapUnreachable();
}
def NOP() {
}
def LOCAL_GET() {
	def index = imm_readULEB32();
	def tv = f_getLocalType(index);
	def val = getLocal(tv, index);
	push_Value(tv, val);
}
def LOCAL_SET() {
	def index = imm_readULEB32();
	def tv = f_getLocalType(index);
	def val = pop_Value(tv);
	setLocal(tv, index, val);
}
def LOCAL_TEE() {
	def index = imm_readULEB32();
	def tv = f_getLocalType(index);
	def val = pop_Value(tv);
	setLocal(tv, index, val);
	push_Value(tv, val);
}
def GLOBAL_GET() {
	def index = imm_readULEB32();
	def tv = m_getGlobalType(index);
	def val = getGlobal(tv, index);
	push_Value(tv, val);
}
def GLOBAL_SET() {
	def index = imm_readULEB32();
	def tv = m_getGlobalType(index);
	def val = pop_Value(tv);
	setGlobal(tv, index, val);
}
def TABLE_GET() {
	def table_index = imm_readULEB32();
	def cond = m_isTable64(table_index);
	if (cond) {
		def index = pop_u64();
		def val = mach_readTable64(table_index, index);
		push_Object(val);
	} else {
		def index1 = pop_u32();
		def val1 = mach_readTable32(table_index, index1);
		push_Object(val1);
	}
}
def TABLE_SET() {
	def table_index = imm_readULEB32();
	def cond = m_isTable64(table_index);
	if (cond) {
		def val = pop_Object();
		def index = pop_u64();
		mach_writeTable64(table_index, index, val);
	} else {
		def val1 = pop_Object();
		def index1 = pop_u32();
		mach_writeTable32(table_index, index1, val1);
	}
}
def CALL() {
	def index = imm_readULEB32();
	def sig = m_getFuncSignature(index);
	def target = i_getFunction(index);
	doCall(sig, target);
}
def CALL_INDIRECT() {
	def sig_index = imm_readULEB32();
	def table_index = imm_readULEB32();
	def sig = m_getSignature(sig_index);
	def is = m_isTable64(table_index);
	if (is) {
		def func_index = pop_u64();
		def target = i_getTableFunction64(table_index, sig, func_index);
		doCall(sig, target);
	} else {
		def func_index1 = pop_u32();
		def target1 = i_getTableFunction32(table_index, sig, func_index1);
		doCall(sig, target1);
	}
}
def RETURN_CALL() {
	def index = imm_readULEB32();
	def sig = m_getFuncSignature(index);
	def target = i_getFunction(index);
	doReturnCall(sig, target);
}
def DROP() {
	def tv = f_getTopOfStackType();
	pop_Value(tv);
}
def SELECT() {
	def c = pop_u32();
	def tv = f_getTopOfStackType();
	def b = pop_Value(tv);
	def a = pop_Value(tv);
	if (u32.!=(c, 0)) {
		push_Value(tv, a);
	} else {
		push_Value(tv, b);
	}
}
def I32_CONST() {
	def x = imm_readILEB32();
	push_u32(x);
}
def I32_ADD() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(u32.+(a, b));
}
def I32_SUB() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(u32.-(a, b));
}
def I32_MUL() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(u32.*(a, b));
}
def I32_DIV_S() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.==(b, 0)) {
		trapDivideByZero();
	}
	def cond = bool.&&(u32.==(b, u32.view(-1)), u32.==(a, u32.view(-2_147_483_648)));
	if (cond) {
		trapDivideUnrepresentable();
	}
	push_u32(u32_div_s(a, b));
}
def I32_DIV_U() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.==(b, 0)) {
		trapDivideByZero();
	}
	push_u32(u32./(a, b));
}
def I32_EQZ() {
	def a = pop_u32();
	if (u32.==(a, 0)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_EQ() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.==(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_NE() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.!=(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_LT_U() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.<(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_LT_S() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32_lt_s(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_LE_S() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32_le_s(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_GT_U() {
	def b = pop_u32();
	def a = pop_u32();
	if (u32.>(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def I32_AND() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(u32.&(a, b));
}
def F32_CONST() {
	def x = imm_readULEB32();
	def arg = f32_reinterpret_u32(x);
	push_f32(arg);
}
def F32_ADD() {
	def b = pop_f32();
	def a = pop_f32();
	push_f32(float.+(a, b));
}
def F32_SUB() {
	def b = pop_f32();
	def a = pop_f32();
	push_f32(float.-(a, b));
}
def F32_MUL() {
	def b = pop_f32();
	def a = pop_f32();
	push_f32(float.*(a, b));
}
def F32_DIV() {
	def b = pop_f32();
	def a = pop_f32();
	if (float.==(b, 0.0f)) {
		trapDivideByZero();
	}
	push_f32(float./(a, b));
}
def F32_SQRT() {
	def a = pop_f32();
	push_f32(float.sqrt(a));
}
def F32_EQ() {
	def b = pop_f32();
	def a = pop_f32();
	if (float.==(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def F32_NE() {
	def b = pop_f32();
	def a = pop_f32();
	if (float.!=(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def F32_LT() {
	def b = pop_f32();
	def a = pop_f32();
	if (float.<(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def F32_LE() {
	def b = pop_f32();
	def a = pop_f32();
	if (float.<=(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def F32_GT() {
	def b = pop_f32();
	def a = pop_f32();
	if (float.>(a, b)) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def BR() {
	def depth = imm_readULEB32();
	def label = f_getLabel(depth);
	doBranch(label);
}
def BR_IF() {
	def depth = imm_readULEB32();
	def label = f_getLabel(depth);
	def cond = pop_u32();
	if (u32.!=(cond, 0)) {
		doBranch(label);
	} else {
		doFallthru();
	}
}
def BLOCK() {
	def bt = imm_readBlockType();
	doBlock(bt);
}
def LOOP() {
	def bt = imm_readBlockType();
	doLoop(bt);
}
def TRY() {
	def bt = imm_readBlockType();
	doTry(bt);
}
def IF() {
	def bt = imm_readBlockType();
	def cond = pop_u32();
	def label = doIf(bt);
	if (u32.==(cond, 0)) {
		doBranch(label);
	} else {
		doFallthru();
	}
}
def ELSE() {
	def label = doElse();
	doBranch(label);
}
def END() {
	doEnd();
	if (f_isAtEnd()) {
		doReturn();
	}
}
def RETURN() {
	doReturn();
}
def REF_NULL() {
	def idx = imm_readULEB32();
	def arg = object_Null();
	push_Object(arg);
}
def REF_IS_NULL() {
	def obj = pop_Object();
	def cond = object_isNull(obj);
	if (cond) {
		push_u32(1);
	} else {
		push_u32(0);
	}
}
def REF_AS_NON_NULL() {
	def obj = pop_Object();
	def cond = object_isNull(obj);
	if (cond) {
		trapNull();
	}
	push_Object(obj);
}
def STRUCT_NEW() {
	def struct_idx = imm_readULEB32();
	def sig = m_getSignature(struct_idx);
	push_Object(object_New(sig));
}
def STRUCT_GET() {
	def struct_index = imm_readULEB32();
	def field_index = imm_readULEB32();
	def kind = m_getFieldKind(struct_index, field_index);
	def offset = m_getFieldOffset(struct_index, field_index);
	def obj = pop_Object();
	def cond = object_isNull(obj);
	if (cond) {
		trapNull();
	}
	match (kind) {
		U32 => {
			def arg = mach_readStructField_u32(obj, offset);
			push_u32(arg);
		}
		U64 => {
			def arg1 = mach_readStructField_u64(obj, offset);
			push_u64(arg1);
		}
		F32 => {
			def arg2 = mach_readStructField_f32(obj, offset);
			push_f32(arg2);
		}
		F64 => {
			def arg3 = mach_readStructField_f64(obj, offset);
			push_f64(arg3);
		}
		V128 => {
			def arg4 = mach_readStructField_v128(obj, offset);
			push_v128(arg4);
		}
		REF => {
			def arg5 = mach_readStructField_Object(obj, offset);
			push_Object(arg5);
		}
		_ => trapUnreachable();
	}
}
def STRUCT_GET_S() {
	def struct_index = imm_readULEB32();
	def field_index = imm_readULEB32();
	def kind = m_getFieldKind(struct_index, field_index);
	def offset = m_getFieldOffset(struct_index, field_index);
	def obj = pop_Object();
	def cond = object_isNull(obj);
	if (cond) {
		trapNull();
	}
	match (kind) {
		U8 => {
			def arg = mach_readStructField_u8(obj, offset);
			push_u32(u32.view(arg));
		}
		U16 => {
			def arg1 = mach_readStructField_u16(obj, offset);
			push_u32(u32.view(arg1));
		}
		_ => trapUnreachable();
	}
}
def STRUCT_GET_U() {
	def struct_index = imm_readULEB32();
	def field_index = imm_readULEB32();
	def kind = m_getFieldKind(struct_index, field_index);
	def offset = m_getFieldOffset(struct_index, field_index);
	def obj = pop_Object();
	def cond = object_isNull(obj);
	if (cond) {
		trapNull();
	}
	match (kind) {
		U8 => {
			def arg = mach_readStructField_u8(obj, offset);
			push_u32(u32.view(arg));
		}
		U16 => {
			def arg1 = mach_readStructField_u16(obj, offset);
			push_u32(u32.view(arg1));
		}
		_ => trapUnreachable();
	}
}
def I32_LOAD() {
	def flags = imm_readU8();
	if (u8.==(u8.&(flags, HAS_MEM_INDEX), 0)) {
	}
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u32(0u, index, offset);
		push_u32(val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		def val1 = mach_readMemory32_u32(0u, index1, offset1);
		push_u32(val1);
	}
}
def I32_LOAD8_U() {
	def flags = imm_readU8();
	if (u8.==(u8.&(flags, HAS_MEM_INDEX), 0)) {
	}
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u8(0u, index, offset);
		push_u32(val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		def val1 = mach_readMemory32_u8(0u, index1, offset1);
		push_u32(val1);
	}
}
def I32_LOAD16_S() {
	def flags = imm_readU8();
	if (u8.==(u8.&(flags, HAS_MEM_INDEX), 0)) {
	}
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u16(0u, index, offset);
		push_u32(val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		def val1 = mach_readMemory32_u16(0u, index1, offset1);
		push_u32(val1);
	}
}
def I64_LOAD() {
	def flags = imm_readU8();
	if (u8.==(u8.&(flags, HAS_MEM_INDEX), 0)) {
	}
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u64(0u, index, offset);
		push_u64(val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		def val1 = mach_readMemory32_u64(0u, index1, offset1);
		push_u64(val1);
	}
}
def F32_LOAD() {
	def flags = imm_readU8();
	if (u8.==(u8.&(flags, HAS_MEM_INDEX), 0)) {
	}
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_f32(0u, index, offset);
		push_f32(val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		def val1 = mach_readMemory32_f32(0u, index1, offset1);
		push_f32(val1);
	}
}
def F64_LOAD() {
	def flags = imm_readU8();
	if (u8.==(u8.&(flags, HAS_MEM_INDEX), 0)) {
	}
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_f64(0u, index, offset);
		push_f64(val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		def val1 = mach_readMemory32_f64(0u, index1, offset1);
		push_f64(val1);
	}
}
def I32_STORE() {
	def flags = imm_readU8();
	if (u8.==(u8.&(flags, HAS_MEM_INDEX), 0)) {
	}
	def val = pop_u32();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u32(0u, index, offset, val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		mach_writeMemory32_u32(0u, index1, offset1, val);
	}
}
def I32_STORE8() {
	def flags = imm_readU8();
	if (u8.==(u8.&(flags, HAS_MEM_INDEX), 0)) {
	}
	def val = pop_u32();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u8(0u, index, offset, val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		mach_writeMemory32_u8(0u, index1, offset1, val);
	}
}
def I32_STORE16() {
	def flags = imm_readU8();
	if (u8.==(u8.&(flags, HAS_MEM_INDEX), 0)) {
	}
	def val = pop_u32();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u16(0u, index, offset, val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		mach_writeMemory32_u16(0u, index1, offset1, val);
	}
}
def I64_STORE() {
	def flags = imm_readU8();
	if (u8.==(u8.&(flags, HAS_MEM_INDEX), 0)) {
	}
	def val = pop_u64();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u64(0u, index, offset, val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		mach_writeMemory32_u64(0u, index1, offset1, val);
	}
}
def F32_STORE() {
	def flags = imm_readU8();
	if (u8.==(u8.&(flags, HAS_MEM_INDEX), 0)) {
	}
	def val = pop_f32();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
	}
}
def F64_STORE() {
	def flags = imm_readU8();
	if (u8.==(u8.&(flags, HAS_MEM_INDEX), 0)) {
	}
	def val = pop_f64();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_f64(0u, index, offset, val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		mach_writeMemory32_f64(0u, index1, offset1, val);
	}
}
def build_dispatch_table() -> Array<void -> void> {
  DISPATCH_TABLE = Array.new(0xE5 + 1);
  for (i < 0xE5 + 1) DISPATCH_TABLE[i] = trapUnreachable;
  DISPATCH_TABLE[Opcode.UNREACHABLE.tag] = UNREACHABLE;
  DISPATCH_TABLE[Opcode.NOP.tag] = NOP;
  DISPATCH_TABLE[Opcode.LOCAL_GET.tag] = LOCAL_GET;
  DISPATCH_TABLE[Opcode.LOCAL_SET.tag] = LOCAL_SET;
  DISPATCH_TABLE[Opcode.LOCAL_TEE.tag] = LOCAL_TEE;
  DISPATCH_TABLE[Opcode.GLOBAL_GET.tag] = GLOBAL_GET;
  DISPATCH_TABLE[Opcode.GLOBAL_SET.tag] = GLOBAL_SET;
  DISPATCH_TABLE[Opcode.TABLE_GET.tag] = TABLE_GET;
  DISPATCH_TABLE[Opcode.TABLE_SET.tag] = TABLE_SET;
  DISPATCH_TABLE[Opcode.CALL.tag] = CALL;
  DISPATCH_TABLE[Opcode.CALL_INDIRECT.tag] = CALL_INDIRECT;
  DISPATCH_TABLE[Opcode.RETURN_CALL.tag] = RETURN_CALL;
  DISPATCH_TABLE[Opcode.DROP.tag] = DROP;
  DISPATCH_TABLE[Opcode.SELECT.tag] = SELECT;
  DISPATCH_TABLE[Opcode.I32_CONST.tag] = I32_CONST;
  DISPATCH_TABLE[Opcode.I32_ADD.tag] = I32_ADD;
  DISPATCH_TABLE[Opcode.I32_SUB.tag] = I32_SUB;
  DISPATCH_TABLE[Opcode.I32_MUL.tag] = I32_MUL;
  DISPATCH_TABLE[Opcode.I32_DIV_S.tag] = I32_DIV_S;
  DISPATCH_TABLE[Opcode.I32_DIV_U.tag] = I32_DIV_U;
  DISPATCH_TABLE[Opcode.I32_EQZ.tag] = I32_EQZ;
  DISPATCH_TABLE[Opcode.I32_EQ.tag] = I32_EQ;
  DISPATCH_TABLE[Opcode.I32_NE.tag] = I32_NE;
  DISPATCH_TABLE[Opcode.I32_LT_U.tag] = I32_LT_U;
  DISPATCH_TABLE[Opcode.I32_LT_S.tag] = I32_LT_S;
  DISPATCH_TABLE[Opcode.I32_LE_S.tag] = I32_LE_S;
  DISPATCH_TABLE[Opcode.I32_GT_U.tag] = I32_GT_U;
  DISPATCH_TABLE[Opcode.I32_AND.tag] = I32_AND;
  DISPATCH_TABLE[Opcode.F32_CONST.tag] = F32_CONST;
  DISPATCH_TABLE[Opcode.F32_ADD.tag] = F32_ADD;
  DISPATCH_TABLE[Opcode.F32_SUB.tag] = F32_SUB;
  DISPATCH_TABLE[Opcode.F32_MUL.tag] = F32_MUL;
  DISPATCH_TABLE[Opcode.F32_DIV.tag] = F32_DIV;
  DISPATCH_TABLE[Opcode.F32_SQRT.tag] = F32_SQRT;
  DISPATCH_TABLE[Opcode.F32_EQ.tag] = F32_EQ;
  DISPATCH_TABLE[Opcode.F32_NE.tag] = F32_NE;
  DISPATCH_TABLE[Opcode.F32_LT.tag] = F32_LT;
  DISPATCH_TABLE[Opcode.F32_LE.tag] = F32_LE;
  DISPATCH_TABLE[Opcode.F32_GT.tag] = F32_GT;
  DISPATCH_TABLE[Opcode.BR.tag] = BR;
  DISPATCH_TABLE[Opcode.BR_IF.tag] = BR_IF;
  DISPATCH_TABLE[Opcode.BLOCK.tag] = BLOCK;
  DISPATCH_TABLE[Opcode.LOOP.tag] = LOOP;
  DISPATCH_TABLE[Opcode.TRY.tag] = TRY;
  DISPATCH_TABLE[Opcode.IF.tag] = IF;
  DISPATCH_TABLE[Opcode.ELSE.tag] = ELSE;
  DISPATCH_TABLE[Opcode.END.tag] = END;
  DISPATCH_TABLE[Opcode.RETURN.tag] = RETURN;
  DISPATCH_TABLE[Opcode.REF_NULL.tag] = REF_NULL;
  DISPATCH_TABLE[Opcode.REF_IS_NULL.tag] = REF_IS_NULL;
  DISPATCH_TABLE[Opcode.REF_AS_NON_NULL.tag] = REF_AS_NON_NULL;
  DISPATCH_TABLE[Opcode.STRUCT_NEW.tag] = STRUCT_NEW;
  DISPATCH_TABLE[Opcode.STRUCT_GET.tag] = STRUCT_GET;
  DISPATCH_TABLE[Opcode.STRUCT_GET_S.tag] = STRUCT_GET_S;
  DISPATCH_TABLE[Opcode.STRUCT_GET_U.tag] = STRUCT_GET_U;
  DISPATCH_TABLE[Opcode.I32_LOAD.tag] = I32_LOAD;
  DISPATCH_TABLE[Opcode.I32_LOAD8_U.tag] = I32_LOAD8_U;
  DISPATCH_TABLE[Opcode.I32_LOAD16_S.tag] = I32_LOAD16_S;
  DISPATCH_TABLE[Opcode.I64_LOAD.tag] = I64_LOAD;
  DISPATCH_TABLE[Opcode.F32_LOAD.tag] = F32_LOAD;
  DISPATCH_TABLE[Opcode.F64_LOAD.tag] = F64_LOAD;
  DISPATCH_TABLE[Opcode.I32_STORE.tag] = I32_STORE;
  DISPATCH_TABLE[Opcode.I32_STORE8.tag] = I32_STORE8;
  DISPATCH_TABLE[Opcode.I32_STORE16.tag] = I32_STORE16;
  DISPATCH_TABLE[Opcode.I64_STORE.tag] = I64_STORE;
  DISPATCH_TABLE[Opcode.F32_STORE.tag] = F32_STORE;
  DISPATCH_TABLE[Opcode.F64_STORE.tag] = F64_STORE;
  return DISPATCH_TABLE;
}
}
