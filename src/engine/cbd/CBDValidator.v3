// GENERATED BY ValidatorGen.v3
def UNREACHABLE() {
	// eff01 -- static: yes, type: <bottom>, effect: ctl

	trapUnreachable();
}
def NOP() {
	// ret23 -- static: no, type: <bottom>, effect: none

}
def LOCAL_GET() {
	// eff418 -- static: no, type: <bottom>, effect: push
// arg616 -- static: no, type: <bottom>, effect: none
// arg517 -- static: yes, type: <bottom>, effect: none
// index10 -- static: yes, type: i32, effect: read
// arg813 -- static: yes, type: i32, effect: none
// arg714 -- static: yes, type: <bottom>, effect: none
// arg911 -- static: yes, type: i32, effect: none
// tv12 -- static: yes, type: <bottom>, effect: none
// val15 -- static: no, type: <bottom>, effect: push

	def index = imm_readULEB32();
	def tv = f_getLocalType(index);
	def val = getLocal(tv, index);
	push_Value(tv, val);
}
def LOCAL_SET() {
	// index25 -- static: yes, type: i32, effect: read
// arg2230 -- static: no, type: <bottom>, effect: none
// arg2131 -- static: yes, type: i32, effect: none
// arg2032 -- static: yes, type: <bottom>, effect: none
// tv27 -- static: yes, type: <bottom>, effect: none
// arg2328 -- static: yes, type: <bottom>, effect: none
// eff1933 -- static: no, type: <bottom>, effect: local
// arg2426 -- static: yes, type: i32, effect: none
// val29 -- static: no, type: <bottom>, effect: pop

	def index = imm_readULEB32();
	def tv = f_getLocalType(index);
	def val = pop_Value(tv);
	setLocal(tv, index, val);
}
def LOCAL_TEE() {
	// val47 -- static: no, type: <bottom>, effect: pop
// arg4048 -- static: no, type: <bottom>, effect: none
// arg3850 -- static: yes, type: <bottom>, effect: none
// arg3652 -- static: no, type: <bottom>, effect: none
// arg3553 -- static: yes, type: <bottom>, effect: none
// arg4146 -- static: yes, type: <bottom>, effect: none
// eff3751 -- static: no, type: <bottom>, effect: local
// eff3454 -- static: no, type: <bottom>, effect: push
// arg4244 -- static: yes, type: i32, effect: none
// index43 -- static: yes, type: i32, effect: read
// arg3949 -- static: yes, type: i32, effect: none
// tv45 -- static: yes, type: <bottom>, effect: none

	def index = imm_readULEB32();
	def tv = f_getLocalType(index);
	def val = pop_Value(tv);
	setLocal(tv, index, val);
	push_Value(tv, val);
}
def GLOBAL_GET() {
	// val66 -- static: no, type: <bottom>, effect: push
// index61 -- static: yes, type: i32, effect: read
// arg6062 -- static: yes, type: i32, effect: none
// tv63 -- static: yes, type: <bottom>, effect: none
// arg5767 -- static: no, type: <bottom>, effect: none
// arg5668 -- static: yes, type: <bottom>, effect: none
// arg5964 -- static: yes, type: i32, effect: none
// arg5865 -- static: yes, type: <bottom>, effect: none
// eff5569 -- static: no, type: <bottom>, effect: push

	def index = imm_readULEB32();
	def tv = m_getGlobalType(index);
	def val = getGlobal(tv, index);
	push_Value(tv, val);
}
def GLOBAL_SET() {
	// arg7479 -- static: yes, type: <bottom>, effect: none
// arg7577 -- static: yes, type: i32, effect: none
// index76 -- static: yes, type: i32, effect: read
// tv78 -- static: yes, type: <bottom>, effect: none
// val80 -- static: no, type: <bottom>, effect: pop
// arg7381 -- static: no, type: <bottom>, effect: none
// arg7282 -- static: yes, type: i32, effect: none
// arg7183 -- static: yes, type: <bottom>, effect: none
// eff7084 -- static: no, type: <bottom>, effect: global

	def index = imm_readULEB32();
	def tv = m_getGlobalType(index);
	def val = pop_Value(tv);
	setGlobal(tv, index, val);
}
def TABLE_GET() {
	// arg93105 -- static: no, type: i32, effect: none
// val107 -- static: no, type: <bottom>, effect: none
// index104 -- static: no, type: i32, effect: pop
// index98 -- static: no, type: i64, effect: pop
// eff86103 -- static: no, type: <bottom>, effect: push
// arg9496 -- static: yes, type: i32, effect: none
// val101 -- static: no, type: <bottom>, effect: none
// arg87102 -- static: no, type: <bottom>, effect: none
// eff90109 -- static: no, type: <bottom>, effect: push
// cond8597 -- static: yes, type: <bottom>, effect: none
// arg88100 -- static: yes, type: i32, effect: none
// arg91108 -- static: no, type: <bottom>, effect: none
// table_index95 -- static: yes, type: i32, effect: read
// arg8999 -- static: no, type: i64, effect: none
// arg92106 -- static: yes, type: i32, effect: none

	def table_index = imm_readULEB32();
	def cond = m_isTable64(table_index);
	if (cond) {
		def index = pop_u64();
		def val = mach_readTable64(table_index, index);
		push_Object(val);
	} else {
		def index1 = pop_u32();
		def val1 = mach_readTable32(table_index, index1);
		push_Object(val1);
	}
}
def TABLE_SET() {
	// arg113126 -- static: no, type: i64, effect: none
// cond110122 -- static: yes, type: <bottom>, effect: none
// arg114125 -- static: no, type: <bottom>, effect: none
// val129 -- static: no, type: <bottom>, effect: pop
// table_index120 -- static: yes, type: i32, effect: read
// index124 -- static: no, type: i64, effect: pop
// eff115134 -- static: no, type: <bottom>, effect: table
// arg116133 -- static: yes, type: i32, effect: none
// val123 -- static: no, type: <bottom>, effect: pop
// arg117132 -- static: no, type: i32, effect: none
// arg119121 -- static: yes, type: i32, effect: none
// index130 -- static: no, type: i32, effect: pop
// arg118131 -- static: no, type: <bottom>, effect: none
// eff111128 -- static: no, type: <bottom>, effect: table
// arg112127 -- static: yes, type: i32, effect: none

	def table_index = imm_readULEB32();
	def cond = m_isTable64(table_index);
	if (cond) {
		def val = pop_Object();
		def index = pop_u64();
		mach_writeTable64(table_index, index, val);
	} else {
		def val1 = pop_Object();
		def index1 = pop_u32();
		mach_writeTable32(table_index, index1, val1);
	}
}
def CALL() {
	// eff135147 -- static: yes, type: <bottom>, effect: ctl
// arg136146 -- static: yes, type: <bottom>, effect: none
// arg137145 -- static: yes, type: <bottom>, effect: none
// arg138143 -- static: yes, type: i32, effect: none
// target144 -- static: yes, type: <bottom>, effect: none
// arg139141 -- static: yes, type: i32, effect: none
// sig142 -- static: yes, type: <bottom>, effect: none
// index140 -- static: yes, type: i32, effect: read

	def index = imm_readULEB32();
	def sig = m_getFuncSignature(index);
	def target = i_getFunction(index);
	doCall(sig, target);
}
def CALL_INDIRECT() {
	// arg151175 -- static: no, type: <bottom>, effect: none
// func_index178 -- static: no, type: i32, effect: pop
// table_index164 -- static: yes, type: i32, effect: read
// arg152173 -- static: yes, type: i32, effect: none
// cond148169 -- static: yes, type: <bottom>, effect: none
// arg153172 -- static: yes, type: <bottom>, effect: none
// eff155185 -- static: no, type: <bottom>, effect: ctl
// arg154171 -- static: no, type: i64, effect: none
// arg156184 -- static: yes, type: <bottom>, effect: none
// eff149177 -- static: no, type: <bottom>, effect: ctl
// sig_index163 -- static: yes, type: i32, effect: read
// sig166 -- static: yes, type: <bottom>, effect: none
// func_index170 -- static: no, type: i64, effect: pop
// arg157183 -- static: no, type: <bottom>, effect: none
// arg160179 -- static: no, type: i32, effect: none
// is64168 -- static: yes, type: <bottom>, effect: none
// target174 -- static: no, type: <bottom>, effect: none
// arg161167 -- static: yes, type: i32, effect: none
// arg158181 -- static: yes, type: i32, effect: none
// arg150176 -- static: yes, type: <bottom>, effect: none
// arg159180 -- static: yes, type: <bottom>, effect: none
// target182 -- static: no, type: <bottom>, effect: none
// arg162165 -- static: yes, type: i32, effect: none

	def sig_index = imm_readULEB32();
	def table_index = imm_readULEB32();
	def sig = m_getSignature(sig_index);
	def is = m_isTable64(table_index);
	if (is) {
		def func_index = pop_u64();
		def target = i_getTableFunction64(table_index, sig, func_index);
		doCall(sig, target);
	} else {
		def func_index1 = pop_u32();
		def target1 = i_getTableFunction32(table_index, sig, func_index1);
		doCall(sig, target1);
	}
}
def RETURN_CALL() {
	// index191 -- static: yes, type: i32, effect: read
// arg190192 -- static: yes, type: i32, effect: none
// eff186198 -- static: yes, type: <bottom>, effect: ctl
// arg187197 -- static: yes, type: <bottom>, effect: none
// arg188196 -- static: yes, type: <bottom>, effect: none
// arg189194 -- static: yes, type: i32, effect: none
// target195 -- static: yes, type: <bottom>, effect: none
// sig193 -- static: yes, type: <bottom>, effect: none

	def index = imm_readULEB32();
	def sig = m_getFuncSignature(index);
	def target = i_getFunction(index);
	doReturnCall(sig, target);
}
def DROP() {
	// arg200202 -- static: yes, type: <bottom>, effect: none
// tv201 -- static: yes, type: <bottom>, effect: none
// eff199203 -- static: no, type: <bottom>, effect: pop

	def tv = f_getTopOfStackType();
	pop_Value(tv);
}
def SELECT() {
	// arg211222 -- static: no, type: i32, effect: none
// b218 -- static: no, type: <bottom>, effect: pop
// arg212221 -- static: yes, type: i32, effect: none
// eff205226 -- static: no, type: <bottom>, effect: push
// eff208229 -- static: no, type: <bottom>, effect: push
// arg206225 -- static: yes, type: <bottom>, effect: none
// arg209228 -- static: yes, type: <bottom>, effect: none
// cond204223 -- static: no, type: i32, effect: none
// arg207224 -- static: no, type: <bottom>, effect: none
// c215 -- static: no, type: i32, effect: pop
// rtcast230 -- static: no, type: i32, effect: none
// arg213219 -- static: yes, type: <bottom>, effect: none
// a220 -- static: no, type: <bottom>, effect: pop
// arg210227 -- static: no, type: <bottom>, effect: none
// tv216 -- static: yes, type: <bottom>, effect: none
// arg214217 -- static: yes, type: <bottom>, effect: none

	def c = pop_u32();
	def tv = f_getTopOfStackType();
	def b = pop_Value(tv);
	def a = pop_Value(tv);
	push_Value(tv, a);
}
def I32_CONST() {
	// arg232234 -- static: yes, type: i32, effect: none
// x233 -- static: yes, type: i32, effect: read
// rtcast236 -- static: no, type: i32, effect: none
// eff231235 -- static: yes, type: <bottom>, effect: push

	def x = imm_readILEB32();
	push_u32(rtcast_i32(x));
}
def I32_ADD() {
	// eff237247 -- static: no, type: <bottom>, effect: push
// arg238246 -- static: no, type: i32, effect: none
// arg239244 -- static: no, type: i32, effect: none
// r245 -- static: no, type: i32, effect: none
// a242 -- static: no, type: i32, effect: pop
// b241 -- static: no, type: i32, effect: pop
// arg240243 -- static: no, type: i32, effect: none

	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_plus(a, b));
}
def I32_SUB() {
	// eff248258 -- static: no, type: <bottom>, effect: push
// arg249257 -- static: no, type: i32, effect: none
// r256 -- static: no, type: i32, effect: none
// a253 -- static: no, type: i32, effect: pop
// arg250255 -- static: no, type: i32, effect: none
// b252 -- static: no, type: i32, effect: pop
// arg251254 -- static: no, type: i32, effect: none

	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_minus(a, b));
}
def I32_MUL() {
	// eff259269 -- static: no, type: <bottom>, effect: push
// r267 -- static: no, type: i32, effect: none
// arg260268 -- static: no, type: i32, effect: none
// a264 -- static: no, type: i32, effect: pop
// arg261266 -- static: no, type: i32, effect: none
// b263 -- static: no, type: i32, effect: pop
// arg262265 -- static: no, type: i32, effect: none

	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_times(a, b));
}
def I32_DIV_S() {
	// arg282295 -- static: no, type: i32, effect: none
// ret275303 -- static: yes, type: <bottom>, effect: ctl
// arg283294 -- static: yes, type: i32, effect: none
// arg278300 -- static: no, type: i32, effect: none
// eff270308 -- static: no, type: <bottom>, effect: push
// arg277297 -- static: no, type: i32, effect: none
// arg279299 -- static: no, type: i32, effect: none
// r306 -- static: no, type: i32, effect: none
// arg271307 -- static: no, type: i32, effect: none
// cond284292 -- static: no, type: i32, effect: none
// arg272305 -- static: no, type: i32, effect: none
// arg286291 -- static: no, type: i32, effect: none
// a289 -- static: no, type: i32, effect: pop
// arg273304 -- static: no, type: i32, effect: none
// arg287290 -- static: yes, type: i32, effect: none
// ret285293 -- static: yes, type: <bottom>, effect: ctl
// b288 -- static: no, type: i32, effect: pop
// arg280298 -- static: yes, type: i32, effect: none
// cond274302 -- static: no, type: i32, effect: none
// rtcast309 -- static: no, type: i32, effect: none
// arg281296 -- static: no, type: i32, effect: none
// arg276301 -- static: no, type: i32, effect: none

	def b = pop_u32();
	def a = pop_u32();
	trapDivideByZero();
	trapDivideUnrepresentable();
	push_u32(u32_div_s(a, b));
}
def I32_DIV_U() {
	// arg312325 -- static: no, type: i32, effect: none
// a319 -- static: no, type: i32, effect: pop
// arg313324 -- static: no, type: i32, effect: none
// b318 -- static: no, type: i32, effect: pop
// cond314322 -- static: no, type: i32, effect: none
// r326 -- static: no, type: i32, effect: none
// arg316321 -- static: no, type: i32, effect: none
// arg317320 -- static: yes, type: i32, effect: none
// ret315323 -- static: yes, type: <bottom>, effect: ctl
// eff310328 -- static: no, type: <bottom>, effect: push
// arg311327 -- static: no, type: i32, effect: none
// rtcast329 -- static: no, type: i32, effect: none

	def b = pop_u32();
	def a = pop_u32();
	trapDivideByZero();
	push_u32(U32_div(a, b));
}
def I32_EQZ() {
	// arg336338 -- static: yes, type: i32, effect: none
// eff331342 -- static: yes, type: <bottom>, effect: push
// eff333344 -- static: yes, type: <bottom>, effect: push
// cond330340 -- static: no, type: i32, effect: none
// arg332341 -- static: yes, type: i32, effect: none
// arg334343 -- static: yes, type: i32, effect: none
// rtcast346 -- static: no, type: i32, effect: none
// a337 -- static: no, type: i32, effect: pop
// rtcast345 -- static: no, type: i32, effect: none
// arg335339 -- static: no, type: i32, effect: none

	def a = pop_u32();
	push_u32(rtcast_i32(1));
}
def I32_EQ() {
	// eff350362 -- static: yes, type: <bottom>, effect: push
// cond347358 -- static: no, type: i32, effect: none
// arg349359 -- static: yes, type: i32, effect: none
// arg351361 -- static: yes, type: i32, effect: none
// a355 -- static: no, type: i32, effect: pop
// rtcast363 -- static: no, type: i32, effect: none
// b354 -- static: no, type: i32, effect: pop
// arg352357 -- static: no, type: i32, effect: none
// eff348360 -- static: yes, type: <bottom>, effect: push
// arg353356 -- static: no, type: i32, effect: none

	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_i32(1));
}
def I32_NE() {
	// b371 -- static: no, type: i32, effect: pop
// eff365377 -- static: yes, type: <bottom>, effect: push
// eff367379 -- static: yes, type: <bottom>, effect: push
// cond364375 -- static: no, type: i32, effect: none
// arg366376 -- static: yes, type: i32, effect: none
// arg368378 -- static: yes, type: i32, effect: none
// arg369374 -- static: no, type: i32, effect: none
// a372 -- static: no, type: i32, effect: pop
// rtcast380 -- static: no, type: i32, effect: none
// arg370373 -- static: no, type: i32, effect: none

	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_i32(1));
}
def I32_LT_U() {
	// eff382394 -- static: yes, type: <bottom>, effect: push
// eff384396 -- static: yes, type: <bottom>, effect: push
// cond381392 -- static: no, type: i32, effect: none
// arg383393 -- static: yes, type: i32, effect: none
// arg385395 -- static: yes, type: i32, effect: none
// a389 -- static: no, type: i32, effect: pop
// arg386391 -- static: no, type: i32, effect: none
// rtcast397 -- static: no, type: i32, effect: none
// b388 -- static: no, type: i32, effect: pop
// arg387390 -- static: no, type: i32, effect: none

	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_i32(1));
}
def I32_LT_S() {
	// a406 -- static: no, type: i32, effect: pop
// eff399411 -- static: yes, type: <bottom>, effect: push
// eff401413 -- static: yes, type: <bottom>, effect: push
// rtcast414 -- static: no, type: i32, effect: none
// arg400410 -- static: yes, type: i32, effect: none
// arg402412 -- static: yes, type: i32, effect: none
// b405 -- static: no, type: i32, effect: pop
// cond398409 -- static: no, type: i32, effect: none
// arg403408 -- static: no, type: i32, effect: none
// arg404407 -- static: no, type: i32, effect: none

	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_i32(1));
}
def I32_LE_S() {
	// eff416428 -- static: yes, type: <bottom>, effect: push
// cond415426 -- static: no, type: i32, effect: none
// arg417427 -- static: yes, type: i32, effect: none
// arg419429 -- static: yes, type: i32, effect: none
// a423 -- static: no, type: i32, effect: pop
// rtcast431 -- static: no, type: i32, effect: none
// b422 -- static: no, type: i32, effect: pop
// arg420425 -- static: no, type: i32, effect: none
// eff418430 -- static: yes, type: <bottom>, effect: push
// arg421424 -- static: no, type: i32, effect: none

	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_i32(1));
}
def I32_GT_U() {
	// rtcast448 -- static: no, type: i32, effect: none
// eff433445 -- static: yes, type: <bottom>, effect: push
// eff435447 -- static: yes, type: <bottom>, effect: push
// b439 -- static: no, type: i32, effect: pop
// cond432443 -- static: no, type: i32, effect: none
// arg434444 -- static: yes, type: i32, effect: none
// arg436446 -- static: yes, type: i32, effect: none
// arg437442 -- static: no, type: i32, effect: none
// arg438441 -- static: no, type: i32, effect: none
// a440 -- static: no, type: i32, effect: pop

	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_i32(1));
}
def I32_AND() {
	// eff449459 -- static: no, type: <bottom>, effect: push
// r457 -- static: no, type: i32, effect: none
// a454 -- static: no, type: i32, effect: pop
// arg450458 -- static: no, type: i32, effect: none
// b453 -- static: no, type: i32, effect: pop
// arg451456 -- static: no, type: i32, effect: none
// arg452455 -- static: no, type: i32, effect: none

	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_and(a, b));
}
def F32_CONST() {
	// arg462464 -- static: yes, type: i32, effect: none
// x463 -- static: yes, type: i32, effect: read
// rtcast467 -- static: no, type: i32, effect: none
// eff460466 -- static: no, type: <bottom>, effect: push
// arg461465 -- static: no, type: f32, effect: none

	def x = imm_readULEB32();
	def arg = f32_reinterpret_u32(rtcast_i32(x));
	push_f32(arg);
}
def F32_ADD() {
	// eff468478 -- static: no, type: <bottom>, effect: push
// arg469477 -- static: no, type: f32, effect: none
// r476 -- static: no, type: f32, effect: none
// a473 -- static: no, type: f32, effect: pop
// arg470475 -- static: no, type: f32, effect: none
// b472 -- static: no, type: f32, effect: pop
// arg471474 -- static: no, type: f32, effect: none

	def b = pop_f32();
	def a = pop_f32();
	push_f32(F32_plus(a, b));
}
def F32_SUB() {
	// eff479489 -- static: no, type: <bottom>, effect: push
// r487 -- static: no, type: f32, effect: none
// arg480488 -- static: no, type: f32, effect: none
// a484 -- static: no, type: f32, effect: pop
// arg481486 -- static: no, type: f32, effect: none
// b483 -- static: no, type: f32, effect: pop
// arg482485 -- static: no, type: f32, effect: none

	def b = pop_f32();
	def a = pop_f32();
	push_f32(F32_minus(a, b));
}
def F32_MUL() {
	// eff490500 -- static: no, type: <bottom>, effect: push
// r498 -- static: no, type: f32, effect: none
// arg491499 -- static: no, type: f32, effect: none
// a495 -- static: no, type: f32, effect: pop
// arg492497 -- static: no, type: f32, effect: none
// b494 -- static: no, type: f32, effect: pop
// arg493496 -- static: no, type: f32, effect: none

	def b = pop_f32();
	def a = pop_f32();
	push_f32(F32_times(a, b));
}
def F32_DIV() {
	// arg503516 -- static: no, type: f32, effect: none
// arg504515 -- static: no, type: f32, effect: none
// r517 -- static: no, type: f32, effect: none
// cond505513 -- static: no, type: i32, effect: none
// rtcast520 -- static: no, type: f32, effect: none
// a510 -- static: no, type: f32, effect: pop
// arg507512 -- static: no, type: f32, effect: none
// arg508511 -- static: yes, type: f32, effect: none
// ret506514 -- static: yes, type: <bottom>, effect: ctl
// eff501519 -- static: no, type: <bottom>, effect: push
// arg502518 -- static: no, type: f32, effect: none
// b509 -- static: no, type: f32, effect: pop

	def b = pop_f32();
	def a = pop_f32();
	trapDivideByZero();
	push_f32(F32_div(a, b));
}
def F32_SQRT() {
	// arg523525 -- static: no, type: f32, effect: none
// r526 -- static: no, type: <bottom>, effect: none
// a524 -- static: no, type: f32, effect: pop
// eff521528 -- static: no, type: <bottom>, effect: push
// arg522527 -- static: no, type: f32, effect: none

	def a = pop_f32();
	push_f32(F32_sqrt(a));
}
def F32_EQ() {
	// eff530542 -- static: yes, type: <bottom>, effect: push
// eff532544 -- static: yes, type: <bottom>, effect: push
// a537 -- static: no, type: f32, effect: pop
// arg531541 -- static: yes, type: i32, effect: none
// arg533543 -- static: yes, type: i32, effect: none
// rtcast545 -- static: no, type: i32, effect: none
// b536 -- static: no, type: f32, effect: pop
// arg534539 -- static: no, type: f32, effect: none
// cond529540 -- static: no, type: i32, effect: none
// arg535538 -- static: no, type: f32, effect: none

	def b = pop_f32();
	def a = pop_f32();
	push_u32(rtcast_i32(1));
}
def F32_NE() {
	// eff547559 -- static: yes, type: <bottom>, effect: push
// cond546557 -- static: no, type: i32, effect: none
// arg548558 -- static: yes, type: i32, effect: none
// arg550560 -- static: yes, type: i32, effect: none
// a554 -- static: no, type: f32, effect: pop
// rtcast562 -- static: no, type: i32, effect: none
// b553 -- static: no, type: f32, effect: pop
// arg551556 -- static: no, type: f32, effect: none
// eff549561 -- static: yes, type: <bottom>, effect: push
// arg552555 -- static: no, type: f32, effect: none

	def b = pop_f32();
	def a = pop_f32();
	push_u32(rtcast_i32(1));
}
def F32_LT() {
	// eff564576 -- static: yes, type: <bottom>, effect: push
// eff566578 -- static: yes, type: <bottom>, effect: push
// rtcast579 -- static: no, type: i32, effect: none
// cond563574 -- static: no, type: i32, effect: none
// arg565575 -- static: yes, type: i32, effect: none
// arg567577 -- static: yes, type: i32, effect: none
// arg568573 -- static: no, type: f32, effect: none
// arg569572 -- static: no, type: f32, effect: none
// a571 -- static: no, type: f32, effect: pop
// b570 -- static: no, type: f32, effect: pop

	def b = pop_f32();
	def a = pop_f32();
	push_u32(rtcast_i32(1));
}
def F32_LE() {
	// eff581593 -- static: yes, type: <bottom>, effect: push
// eff583595 -- static: yes, type: <bottom>, effect: push
// cond580591 -- static: no, type: i32, effect: none
// arg582592 -- static: yes, type: i32, effect: none
// arg584594 -- static: yes, type: i32, effect: none
// a588 -- static: no, type: f32, effect: pop
// rtcast596 -- static: no, type: i32, effect: none
// arg585590 -- static: no, type: f32, effect: none
// b587 -- static: no, type: f32, effect: pop
// arg586589 -- static: no, type: f32, effect: none

	def b = pop_f32();
	def a = pop_f32();
	push_u32(rtcast_i32(1));
}
def F32_GT() {
	// a605 -- static: no, type: f32, effect: pop
// rtcast613 -- static: no, type: i32, effect: none
// eff598610 -- static: yes, type: <bottom>, effect: push
// eff600612 -- static: yes, type: <bottom>, effect: push
// b604 -- static: no, type: f32, effect: pop
// arg601611 -- static: yes, type: i32, effect: none
// cond597608 -- static: no, type: i32, effect: none
// arg599609 -- static: yes, type: i32, effect: none
// arg602607 -- static: no, type: f32, effect: none
// arg603606 -- static: no, type: f32, effect: none

	def b = pop_f32();
	def a = pop_f32();
	push_u32(rtcast_i32(1));
}
def BR() {
	// arg616618 -- static: yes, type: i32, effect: none
// arg615620 -- static: yes, type: <bottom>, effect: none
// ret614621 -- static: yes, type: <bottom>, effect: ctl
// label619 -- static: yes, type: <bottom>, effect: none
// depth617 -- static: yes, type: i32, effect: read

	def depth = imm_readULEB32();
	def label = f_getLabel(depth);
	doBranch(label);
}
def BR_IF() {
	// cond622635 -- static: no, type: i32, effect: none
// arg624636 -- static: yes, type: <bottom>, effect: none
// cond632 -- static: no, type: i32, effect: pop
// ret623637 -- static: yes, type: <bottom>, effect: ctl
// arg626634 -- static: no, type: i32, effect: none
// ret625638 -- static: yes, type: <bottom>, effect: ctl
// label631 -- static: yes, type: <bottom>, effect: none
// arg627633 -- static: yes, type: i32, effect: none
// arg628630 -- static: yes, type: i32, effect: none
// depth629 -- static: yes, type: i32, effect: read
// rtcast639 -- static: no, type: i32, effect: none

	def depth = imm_readULEB32();
	def label = f_getLabel(depth);
	def cond = pop_u32();
	doBranch(label);
	doFallthru();
}
def BLOCK() {
	// arg641643 -- static: yes, type: <bottom>, effect: none
// bt642 -- static: yes, type: <bottom>, effect: read
// eff640644 -- static: yes, type: <bottom>, effect: ctl

	def bt = imm_readBlockType();
	doBlock(bt);
}
def LOOP() {
	// arg646648 -- static: yes, type: <bottom>, effect: none
// bt647 -- static: yes, type: <bottom>, effect: read
// eff645649 -- static: yes, type: <bottom>, effect: ctl

	def bt = imm_readBlockType();
	doLoop(bt);
}
def TRY() {
	// arg651653 -- static: yes, type: <bottom>, effect: none
// bt652 -- static: yes, type: <bottom>, effect: read
// eff650654 -- static: yes, type: <bottom>, effect: ctl

	def bt = imm_readBlockType();
	doTry(bt);
}
def IF() {
	// ret658671 -- static: yes, type: <bottom>, effect: ctl
// cond655668 -- static: no, type: i32, effect: none
// arg657669 -- static: yes, type: <bottom>, effect: none
// bt662 -- static: yes, type: <bottom>, effect: read
// cond663 -- static: no, type: i32, effect: pop
// arg659667 -- static: no, type: i32, effect: none
// label665 -- static: yes, type: <bottom>, effect: ctl
// rtcast672 -- static: no, type: i32, effect: none
// arg660666 -- static: yes, type: i32, effect: none
// arg661664 -- static: yes, type: <bottom>, effect: none
// ret656670 -- static: yes, type: <bottom>, effect: ctl

	def bt = imm_readBlockType();
	def cond = pop_u32();
	def label = doIf(bt);
	doBranch(label);
	doFallthru();
}
def ELSE() {
	// arg674676 -- static: yes, type: <bottom>, effect: none
// ret673677 -- static: yes, type: <bottom>, effect: ctl
// label675 -- static: yes, type: <bottom>, effect: ctl

	def label = doElse();
	doBranch(label);
}
def END() {
	// eff680681 -- static: yes, type: <bottom>, effect: ctl
// cond678682 -- static: yes, type: <bottom>, effect: none
// ret679683 -- static: yes, type: <bottom>, effect: ctl

	doEnd();
	if (f_isAtEnd()) {
		doReturn();
	}
}
def RETURN() {
	// ret684685 -- static: yes, type: <bottom>, effect: ctl

	doReturn();
}
def REF_NULL() {
	// idx688 -- static: yes, type: i32, effect: read
// arg687689 -- static: no, type: <bottom>, effect: none
// eff686690 -- static: no, type: <bottom>, effect: push

	def idx = imm_readULEB32();
	def arg = object_Null();
	push_Object(arg);
}
def REF_IS_NULL() {
	// arg696698 -- static: no, type: <bottom>, effect: none
// eff692701 -- static: yes, type: <bottom>, effect: push
// eff694703 -- static: yes, type: <bottom>, effect: push
// cond691699 -- static: no, type: i32, effect: none
// arg693700 -- static: yes, type: i32, effect: none
// arg695702 -- static: yes, type: i32, effect: none
// obj697 -- static: no, type: <bottom>, effect: pop
// rtcast704 -- static: no, type: i32, effect: none

	def obj = pop_Object();
	push_u32(rtcast_i32(1));
}
def REF_AS_NON_NULL() {
	// eff705715 -- static: no, type: <bottom>, effect: push
// arg706714 -- static: no, type: <bottom>, effect: none
// cond707712 -- static: no, type: i32, effect: none
// eff708713 -- static: yes, type: <bottom>, effect: ctl
// obj710 -- static: no, type: <bottom>, effect: pop
// arg709711 -- static: no, type: <bottom>, effect: none

	def obj = pop_Object();
	trapNull();
	push_Object(obj);
}
def STRUCT_NEW() {
	// sig722 -- static: yes, type: <bottom>, effect: none
// eff716726 -- static: no, type: <bottom>, effect: push
// arg717725 -- static: no, type: <bottom>, effect: none
// obj724 -- static: no, type: <bottom>, effect: none
// arg718723 -- static: yes, type: <bottom>, effect: none
// struct_idx720 -- static: yes, type: i32, effect: read
// arg719721 -- static: yes, type: i32, effect: none

	def struct_idx = imm_readULEB32();
	def sig = m_getSignature(struct_idx);
	push_Object(object_New(sig));
}
def STRUCT_GET() {
	// eff732779 -- static: no, type: <bottom>, effect: push
// kind763 -- static: yes, type: <bottom>, effect: none
// eff744791 -- static: no, type: <bottom>, effect: push
// eff728775 -- static: no, type: <bottom>, effect: push
// eff748795 -- static: no, type: <bottom>, effect: push
// arg741786 -- static: no, type: f64, effect: none
// arg734777 -- static: no, type: <bottom>, effect: none
// arg730773 -- static: no, type: <bottom>, effect: none
// arg755765 -- static: yes, type: i32, effect: none
// arg750793 -- static: no, type: <bottom>, effect: none
// arg747788 -- static: yes, type: <bottom>, effect: none
// arg743784 -- static: yes, type: <bottom>, effect: none
// obj767 -- static: no, type: <bottom>, effect: pop
// arg757762 -- static: yes, type: i32, effect: none
// arg737782 -- static: no, type: f32, effect: none
// eff740787 -- static: no, type: <bottom>, effect: push
// arg739780 -- static: yes, type: <bottom>, effect: none
// offset766 -- static: yes, type: <bottom>, effect: none
// eff736783 -- static: no, type: <bottom>, effect: push
// ret753770 -- static: yes, type: <bottom>, effect: ctl
// cond752769 -- static: no, type: i32, effect: none
// field_index760 -- static: yes, type: i32, effect: read
// arg754768 -- static: no, type: <bottom>, effect: none
// arg733778 -- static: no, type: i64, effect: none
// arg746789 -- static: no, type: <bottom>, effect: none
// arg742785 -- static: no, type: <bottom>, effect: none
// arg751792 -- static: yes, type: <bottom>, effect: none
// arg735776 -- static: yes, type: <bottom>, effect: none
// arg731772 -- static: yes, type: <bottom>, effect: none
// arg756764 -- static: yes, type: i32, effect: none
// arg758761 -- static: yes, type: i32, effect: none
// struct_index759 -- static: yes, type: i32, effect: read
// arg745790 -- static: no, type: <bottom>, effect: none
// arg729774 -- static: no, type: i32, effect: none
// arg749794 -- static: no, type: <bottom>, effect: none
// arg738781 -- static: no, type: <bottom>, effect: none
// cond727771 -- static: yes, type: <bottom>, effect: none

	def struct_index = imm_readULEB32();
	def field_index = imm_readULEB32();
	def kind = m_getFieldKind(struct_index, field_index);
	def offset = m_getFieldOffset(struct_index, field_index);
	def obj = pop_Object();
	trapNull();
	match (kind) {
		U32 => {
			def arg = mach_readStructField_u32(obj, offset);
			push_u32(arg);
		}
		U64 => {
			def arg1 = mach_readStructField_u64(obj, offset);
			push_u64(arg1);
		}
		F32 => {
			def arg2 = mach_readStructField_f32(obj, offset);
			push_f32(arg2);
		}
		F64 => {
			def arg3 = mach_readStructField_f64(obj, offset);
			push_f64(arg3);
		}
		V128 => {
			def arg4 = mach_readStructField_v128(obj, offset);
			push_v128(arg4);
		}
		REF => {
			def arg5 = mach_readStructField_Object(obj, offset);
			push_Object(arg5);
		}
		_ => trapUnreachable();
	}
}
def STRUCT_GET_S() {
	// field_index815 -- static: yes, type: i32, effect: read
// eff797831 -- static: no, type: <bottom>, effect: push
// eff802836 -- static: no, type: <bottom>, effect: push
// arg810820 -- static: yes, type: i32, effect: none
// arg798830 -- static: no, type: <bottom>, effect: none
// arg803835 -- static: no, type: <bottom>, effect: none
// offset821 -- static: yes, type: <bottom>, effect: none
// arg804834 -- static: no, type: <bottom>, effect: none
// arg805833 -- static: no, type: <bottom>, effect: none
// obj822 -- static: no, type: <bottom>, effect: pop
// cond807824 -- static: no, type: i32, effect: none
// arg806832 -- static: yes, type: <bottom>, effect: none
// arg811819 -- static: yes, type: i32, effect: none
// arg809823 -- static: no, type: <bottom>, effect: none
// arg799829 -- static: no, type: <bottom>, effect: none
// struct_index814 -- static: yes, type: i32, effect: read
// kind818 -- static: yes, type: <bottom>, effect: none
// cond796826 -- static: yes, type: <bottom>, effect: none
// ret808825 -- static: yes, type: <bottom>, effect: ctl
// arg800828 -- static: no, type: <bottom>, effect: none
// arg812817 -- static: yes, type: i32, effect: none
// arg801827 -- static: yes, type: <bottom>, effect: none
// arg813816 -- static: yes, type: i32, effect: none

	def struct_index = imm_readULEB32();
	def field_index = imm_readULEB32();
	def kind = m_getFieldKind(struct_index, field_index);
	def offset = m_getFieldOffset(struct_index, field_index);
	def obj = pop_Object();
	trapNull();
	match (kind) {
		U8 => {
			def arg = mach_readStructField_u8(obj, offset);
			push_u32((arg));
		}
		U16 => {
			def arg1 = mach_readStructField_u16(obj, offset);
			push_u32((arg1));
		}
		_ => trapUnreachable();
	}
}
def STRUCT_GET_U() {
	// eff843877 -- static: no, type: <bottom>, effect: push
// arg851861 -- static: yes, type: i32, effect: none
// arg844876 -- static: no, type: <bottom>, effect: none
// field_index856 -- static: yes, type: i32, effect: read
// arg852860 -- static: yes, type: i32, effect: none
// arg840870 -- static: no, type: <bottom>, effect: none
// arg845875 -- static: no, type: <bottom>, effect: none
// cond837867 -- static: yes, type: <bottom>, effect: none
// offset862 -- static: yes, type: <bottom>, effect: none
// arg846874 -- static: no, type: <bottom>, effect: none
// cond848865 -- static: no, type: i32, effect: none
// arg847873 -- static: yes, type: <bottom>, effect: none
// obj863 -- static: no, type: <bottom>, effect: pop
// ret849866 -- static: yes, type: <bottom>, effect: ctl
// arg841869 -- static: no, type: <bottom>, effect: none
// arg853858 -- static: yes, type: i32, effect: none
// eff838872 -- static: no, type: <bottom>, effect: push
// struct_index855 -- static: yes, type: i32, effect: read
// kind859 -- static: yes, type: <bottom>, effect: none
// arg842868 -- static: yes, type: <bottom>, effect: none
// arg839871 -- static: no, type: <bottom>, effect: none
// arg854857 -- static: yes, type: i32, effect: none
// arg850864 -- static: no, type: <bottom>, effect: none

	def struct_index = imm_readULEB32();
	def field_index = imm_readULEB32();
	def kind = m_getFieldKind(struct_index, field_index);
	def offset = m_getFieldOffset(struct_index, field_index);
	def obj = pop_Object();
	trapNull();
	match (kind) {
		U8 => {
			def arg = mach_readStructField_u8(obj, offset);
			push_u32((arg));
		}
		U16 => {
			def arg1 = mach_readStructField_u16(obj, offset);
			push_u32((arg1));
		}
		_ => trapUnreachable();
	}
}
def I32_LOAD() {
	// arg889902 -- static: yes, type: i32, effect: none
// cond878903 -- static: yes, type: <bottom>, effect: none
// offset912 -- static: yes, type: i32, effect: read
// memindex896 -- static: yes, type: i32, effect: none
// arg881908 -- static: yes, type: i32, effect: none
// arg882907 -- static: no, type: i64, effect: none
// eff879911 -- static: no, type: <bottom>, effect: push
// arg883906 -- static: yes, type: i64, effect: none
// eff884919 -- static: no, type: <bottom>, effect: push
// arg885918 -- static: no, type: i32, effect: none
// cond890901 -- static: no, type: <bottom>, effect: none
// val909 -- static: no, type: i32, effect: none
// arg891900 -- static: no, type: <bottom>, effect: none
// flags895 -- static: yes, type: <bottom>, effect: read
// arg880910 -- static: no, type: i32, effect: none
// arg886916 -- static: yes, type: i32, effect: none
// index905 -- static: no, type: i64, effect: pop
// val917 -- static: no, type: i32, effect: none
// arg893899 -- static: yes, type: <bottom>, effect: none
// arg887915 -- static: no, type: i32, effect: none
// arg892897 -- static: yes, type: <bottom>, effect: none
// arg894898 -- static: no, type: <bottom>, effect: none
// offset904 -- static: yes, type: i64, effect: read
// index913 -- static: no, type: i32, effect: pop
// arg888914 -- static: yes, type: i32, effect: none

	def flags = imm_readU8();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u32(0u, index, offset);
		push_u32(val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		def val1 = mach_readMemory32_u32(0u, index1, offset1);
		push_u32(val1);
	}
}
def I32_LOAD8_U() {
	// arg931944 -- static: yes, type: i32, effect: none
// cond920945 -- static: yes, type: <bottom>, effect: none
// offset946 -- static: yes, type: i64, effect: read
// index955 -- static: no, type: i32, effect: pop
// flags937 -- static: yes, type: <bottom>, effect: read
// arg925948 -- static: yes, type: i64, effect: none
// cond932943 -- static: no, type: <bottom>, effect: none
// offset954 -- static: yes, type: i32, effect: read
// arg933942 -- static: no, type: <bottom>, effect: none
// eff921953 -- static: no, type: <bottom>, effect: push
// val951 -- static: no, type: i32, effect: none
// arg922952 -- static: no, type: i32, effect: none
// arg928958 -- static: yes, type: i32, effect: none
// arg935941 -- static: yes, type: <bottom>, effect: none
// arg929957 -- static: no, type: i32, effect: none
// arg923950 -- static: yes, type: i32, effect: none
// memindex938 -- static: yes, type: i32, effect: none
// arg936940 -- static: no, type: <bottom>, effect: none
// eff926961 -- static: no, type: <bottom>, effect: push
// arg934939 -- static: yes, type: <bottom>, effect: none
// index947 -- static: no, type: i64, effect: pop
// val959 -- static: no, type: i32, effect: none
// arg927960 -- static: no, type: i32, effect: none
// arg930956 -- static: yes, type: i32, effect: none
// arg924949 -- static: no, type: i64, effect: none

	def flags = imm_readU8();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u8(0u, index, offset);
		push_u32(val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		def val1 = mach_readMemory32_u8(0u, index1, offset1);
		push_u32(val1);
	}
}
def I32_LOAD16_S() {
	// arg973986 -- static: yes, type: i32, effect: none
// cond962987 -- static: yes, type: <bottom>, effect: none
// offset988 -- static: yes, type: i64, effect: read
// index997 -- static: no, type: i32, effect: pop
// flags979 -- static: yes, type: <bottom>, effect: read
// cond974985 -- static: no, type: <bottom>, effect: none
// arg975984 -- static: no, type: <bottom>, effect: none
// eff963995 -- static: no, type: <bottom>, effect: push
// arg964994 -- static: no, type: i32, effect: none
// offset996 -- static: yes, type: i32, effect: read
// val1001 -- static: no, type: i32, effect: none
// memindex980 -- static: yes, type: i32, effect: none
// arg977983 -- static: yes, type: <bottom>, effect: none
// val993 -- static: no, type: i32, effect: none
// arg976981 -- static: yes, type: <bottom>, effect: none
// arg965992 -- static: yes, type: i32, effect: none
// arg978982 -- static: no, type: <bottom>, effect: none
// arg966991 -- static: no, type: i64, effect: none
// arg9701000 -- static: yes, type: i32, effect: none
// arg967990 -- static: yes, type: i64, effect: none
// arg971999 -- static: no, type: i32, effect: none
// eff9681003 -- static: no, type: <bottom>, effect: push
// arg972998 -- static: yes, type: i32, effect: none
// arg9691002 -- static: no, type: i32, effect: none
// index989 -- static: no, type: i64, effect: pop

	def flags = imm_readU8();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u16(0u, index, offset);
		push_u32(val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		def val1 = mach_readMemory32_u16(0u, index1, offset1);
		push_u32(val1);
	}
}
def I64_LOAD() {
	// flags1021 -- static: yes, type: <bottom>, effect: read
// val1035 -- static: no, type: i64, effect: none
// cond10041029 -- static: yes, type: <bottom>, effect: none
// index1039 -- static: no, type: i32, effect: pop
// arg10201024 -- static: no, type: <bottom>, effect: none
// index1031 -- static: no, type: i64, effect: pop
// offset1038 -- static: yes, type: i32, effect: read
// eff10051037 -- static: no, type: <bottom>, effect: push
// offset1030 -- static: yes, type: i64, effect: read
// val1043 -- static: no, type: i64, effect: none
// eff10101045 -- static: no, type: <bottom>, effect: push
// cond10161027 -- static: no, type: <bottom>, effect: none
// arg10191025 -- static: yes, type: <bottom>, effect: none
// arg10151028 -- static: yes, type: i32, effect: none
// arg10171026 -- static: no, type: <bottom>, effect: none
// arg10061036 -- static: no, type: i64, effect: none
// arg10071034 -- static: yes, type: i32, effect: none
// arg10081033 -- static: no, type: i64, effect: none
// arg10091032 -- static: yes, type: i64, effect: none
// arg10181023 -- static: yes, type: <bottom>, effect: none
// arg10111044 -- static: no, type: i64, effect: none
// memindex1022 -- static: yes, type: i32, effect: none
// arg10141040 -- static: yes, type: i32, effect: none
// arg10131041 -- static: no, type: i32, effect: none
// arg10121042 -- static: yes, type: i32, effect: none

	def flags = imm_readU8();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u64(0u, index, offset);
		push_u64(val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		def val1 = mach_readMemory32_u64(0u, index1, offset1);
		push_u64(val1);
	}
}
def F32_LOAD() {
	// flags1063 -- static: yes, type: <bottom>, effect: read
// val1077 -- static: no, type: <bottom>, effect: none
// offset1080 -- static: yes, type: i32, effect: read
// arg10611067 -- static: yes, type: <bottom>, effect: none
// arg10621066 -- static: no, type: <bottom>, effect: none
// index1073 -- static: no, type: i64, effect: pop
// arg10571070 -- static: yes, type: i32, effect: none
// arg10501075 -- static: no, type: i64, effect: none
// arg10511074 -- static: yes, type: i64, effect: none
// arg10601065 -- static: yes, type: <bottom>, effect: none
// eff10471079 -- static: no, type: <bottom>, effect: push
// offset1072 -- static: yes, type: i64, effect: read
// val1085 -- static: no, type: <bottom>, effect: none
// eff10521087 -- static: no, type: <bottom>, effect: push
// cond10581069 -- static: no, type: <bottom>, effect: none
// arg10591068 -- static: no, type: <bottom>, effect: none
// arg10481078 -- static: no, type: <bottom>, effect: none
// arg10491076 -- static: yes, type: i32, effect: none
// cond10461071 -- static: yes, type: <bottom>, effect: none
// memindex1064 -- static: yes, type: i32, effect: none
// arg10531086 -- static: no, type: <bottom>, effect: none
// arg10541084 -- static: yes, type: i32, effect: none
// arg10551083 -- static: no, type: i32, effect: none
// arg10561082 -- static: yes, type: i32, effect: none
// index1081 -- static: no, type: i32, effect: pop

	def flags = imm_readU8();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_f32(0u, index, offset);
		push_f32(val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		def val1 = mach_readMemory32_f32(0u, index1, offset1);
		push_f32(val1);
	}
}
def F64_LOAD() {
	// arg10901120 -- static: no, type: <bottom>, effect: none
// offset1122 -- static: yes, type: i32, effect: read
// eff10891121 -- static: no, type: <bottom>, effect: push
// arg11031109 -- static: yes, type: <bottom>, effect: none
// arg11041108 -- static: no, type: <bottom>, effect: none
// arg11021107 -- static: yes, type: <bottom>, effect: none
// index1115 -- static: no, type: i64, effect: pop
// arg10991112 -- static: yes, type: i32, effect: none
// arg10911118 -- static: yes, type: i32, effect: none
// arg10921117 -- static: no, type: i64, effect: none
// arg10931116 -- static: yes, type: i64, effect: none
// offset1114 -- static: yes, type: i64, effect: read
// val1127 -- static: no, type: <bottom>, effect: none
// eff10941129 -- static: no, type: <bottom>, effect: push
// cond10881113 -- static: yes, type: <bottom>, effect: none
// memindex1106 -- static: yes, type: i32, effect: none
// cond11001111 -- static: no, type: <bottom>, effect: none
// arg10951128 -- static: no, type: <bottom>, effect: none
// arg10961126 -- static: yes, type: i32, effect: none
// arg10971125 -- static: no, type: i32, effect: none
// arg10981124 -- static: yes, type: i32, effect: none
// arg11011110 -- static: no, type: <bottom>, effect: none
// index1123 -- static: no, type: i32, effect: pop
// flags1105 -- static: yes, type: <bottom>, effect: read
// val1119 -- static: no, type: <bottom>, effect: none

	def flags = imm_readU8();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_f64(0u, index, offset);
		push_f64(val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		def val1 = mach_readMemory32_f64(0u, index1, offset1);
		push_f64(val1);
	}
}
def I32_STORE() {
	// offset1157 -- static: yes, type: i64, effect: read
// memindex1148 -- static: yes, type: i32, effect: none
// cond11301156 -- static: yes, type: <bottom>, effect: none
// index1158 -- static: no, type: i64, effect: pop
// offset1164 -- static: yes, type: i32, effect: read
// cond11421153 -- static: no, type: <bottom>, effect: none
// val1154 -- static: no, type: i32, effect: pop
// arg11461150 -- static: no, type: <bottom>, effect: none
// arg11451151 -- static: yes, type: <bottom>, effect: none
// arg11411155 -- static: yes, type: i32, effect: none
// index1165 -- static: no, type: i32, effect: pop
// arg11431152 -- static: no, type: <bottom>, effect: none
// arg11401166 -- static: no, type: i32, effect: none
// arg11341160 -- static: yes, type: i64, effect: none
// arg11331161 -- static: no, type: i64, effect: none
// arg11321162 -- static: yes, type: i32, effect: none
// eff11361170 -- static: no, type: <bottom>, effect: memory
// eff11311163 -- static: no, type: <bottom>, effect: memory
// arg11391167 -- static: yes, type: i32, effect: none
// arg11381168 -- static: no, type: i32, effect: none
// arg11371169 -- static: yes, type: i32, effect: none
// flags1147 -- static: yes, type: <bottom>, effect: read
// arg11351159 -- static: no, type: i32, effect: none
// arg11441149 -- static: yes, type: <bottom>, effect: none

	def flags = imm_readU8();
	def val = pop_u32();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u32(0u, index, offset, val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		mach_writeMemory32_u32(0u, index1, offset1, val);
	}
}
def I32_STORE8() {
	// arg11851190 -- static: yes, type: <bottom>, effect: none
// flags1188 -- static: yes, type: <bottom>, effect: read
// offset1198 -- static: yes, type: i64, effect: read
// arg11811207 -- static: no, type: i32, effect: none
// arg11801208 -- static: yes, type: i32, effect: none
// arg11781210 -- static: yes, type: i32, effect: none
// arg11761200 -- static: no, type: i32, effect: none
// arg11751201 -- static: yes, type: i64, effect: none
// arg11741202 -- static: no, type: i64, effect: none
// arg11731203 -- static: yes, type: i32, effect: none
// eff11771211 -- static: no, type: <bottom>, effect: memory
// memindex1189 -- static: yes, type: i32, effect: none
// eff11721204 -- static: no, type: <bottom>, effect: memory
// index1199 -- static: no, type: i64, effect: pop
// arg11791209 -- static: no, type: i32, effect: none
// val1195 -- static: no, type: i32, effect: pop
// cond11711197 -- static: yes, type: <bottom>, effect: none
// cond11831194 -- static: no, type: <bottom>, effect: none
// offset1205 -- static: yes, type: i32, effect: read
// arg11871191 -- static: no, type: <bottom>, effect: none
// arg11861192 -- static: yes, type: <bottom>, effect: none
// arg11821196 -- static: yes, type: i32, effect: none
// arg11841193 -- static: no, type: <bottom>, effect: none
// index1206 -- static: no, type: i32, effect: pop

	def flags = imm_readU8();
	def val = pop_u32();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u8(0u, index, offset, val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		mach_writeMemory32_u8(0u, index1, offset1, val);
	}
}
def I32_STORE16() {
	// val1236 -- static: no, type: i32, effect: pop
// cond12121238 -- static: yes, type: <bottom>, effect: none
// arg12191251 -- static: yes, type: i32, effect: none
// arg12211249 -- static: yes, type: i32, effect: none
// arg12221248 -- static: no, type: i32, effect: none
// memindex1230 -- static: yes, type: i32, effect: none
// offset1239 -- static: yes, type: i64, effect: read
// eff12131245 -- static: no, type: <bottom>, effect: memory
// cond12241235 -- static: no, type: <bottom>, effect: none
// arg12231237 -- static: yes, type: i32, effect: none
// arg12271233 -- static: yes, type: <bottom>, effect: none
// arg12281232 -- static: no, type: <bottom>, effect: none
// arg12251234 -- static: no, type: <bottom>, effect: none
// arg12141244 -- static: yes, type: i32, effect: none
// arg12151243 -- static: no, type: i64, effect: none
// arg12161242 -- static: yes, type: i64, effect: none
// arg12171241 -- static: no, type: i32, effect: none
// arg12261231 -- static: yes, type: <bottom>, effect: none
// index1247 -- static: no, type: i32, effect: pop
// arg12201250 -- static: no, type: i32, effect: none
// index1240 -- static: no, type: i64, effect: pop
// flags1229 -- static: yes, type: <bottom>, effect: read
// eff12181252 -- static: no, type: <bottom>, effect: memory
// offset1246 -- static: yes, type: i32, effect: read

	def flags = imm_readU8();
	def val = pop_u32();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u16(0u, index, offset, val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		mach_writeMemory32_u16(0u, index1, offset1, val);
	}
}
def I64_STORE() {
	// offset1287 -- static: yes, type: i32, effect: read
// val1277 -- static: no, type: i64, effect: pop
// eff12591293 -- static: no, type: <bottom>, effect: memory
// offset1280 -- static: yes, type: i64, effect: read
// cond12531279 -- static: yes, type: <bottom>, effect: none
// arg12631289 -- static: no, type: i64, effect: none
// memindex1271 -- static: yes, type: i32, effect: none
// eff12541286 -- static: no, type: <bottom>, effect: memory
// flags1270 -- static: yes, type: <bottom>, effect: read
// cond12651276 -- static: no, type: <bottom>, effect: none
// arg12641278 -- static: yes, type: i32, effect: none
// arg12681274 -- static: yes, type: <bottom>, effect: none
// arg12691273 -- static: no, type: <bottom>, effect: none
// arg12661275 -- static: no, type: <bottom>, effect: none
// index1288 -- static: no, type: i32, effect: pop
// arg12551285 -- static: yes, type: i32, effect: none
// arg12561284 -- static: no, type: i64, effect: none
// arg12571283 -- static: yes, type: i64, effect: none
// arg12581282 -- static: no, type: i64, effect: none
// arg12671272 -- static: yes, type: <bottom>, effect: none
// index1281 -- static: no, type: i64, effect: pop
// arg12601292 -- static: yes, type: i32, effect: none
// arg12611291 -- static: no, type: i32, effect: none
// arg12621290 -- static: yes, type: i32, effect: none

	def flags = imm_readU8();
	def val = pop_u64();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u64(0u, index, offset, val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		mach_writeMemory32_u64(0u, index1, offset1, val);
	}
}
def F32_STORE() {
	// arg12991323 -- static: no, type: f32, effect: none
// arg12981324 -- static: yes, type: i64, effect: none
// arg12971325 -- static: no, type: i64, effect: none
// arg12961326 -- static: yes, type: i32, effect: none
// eff13001334 -- static: no, type: <bottom>, effect: none
// cond13061317 -- static: no, type: <bottom>, effect: none
// offset1321 -- static: yes, type: i64, effect: read
// eff12951327 -- static: no, type: <bottom>, effect: none
// memindex1312 -- static: yes, type: i32, effect: none
// arg13091315 -- static: yes, type: <bottom>, effect: none
// arg13051319 -- static: yes, type: i32, effect: none
// arg13071316 -- static: no, type: <bottom>, effect: none
// index1322 -- static: no, type: i64, effect: pop
// cond12941320 -- static: yes, type: <bottom>, effect: none
// arg13081313 -- static: yes, type: <bottom>, effect: none
// offset1328 -- static: yes, type: i32, effect: read
// val1318 -- static: no, type: f32, effect: pop
// index1329 -- static: no, type: i32, effect: pop
// arg13101314 -- static: no, type: <bottom>, effect: none
// flags1311 -- static: yes, type: <bottom>, effect: read
// arg13041330 -- static: no, type: f32, effect: none
// arg13031331 -- static: yes, type: i32, effect: none
// arg13021332 -- static: no, type: i32, effect: none
// arg13011333 -- static: yes, type: i32, effect: none

	def flags = imm_readU8();
	def val = pop_f32();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
	}
}
def F64_STORE() {
	// cond13351361 -- static: yes, type: <bottom>, effect: none
// flags1352 -- static: yes, type: <bottom>, effect: read
// arg13511355 -- static: no, type: <bottom>, effect: none
// arg13501356 -- static: yes, type: <bottom>, effect: none
// arg13461360 -- static: yes, type: i32, effect: none
// offset1362 -- static: yes, type: i64, effect: read
// arg13451371 -- static: no, type: f64, effect: none
// arg13441372 -- static: yes, type: i32, effect: none
// arg13431373 -- static: no, type: i32, effect: none
// arg13421374 -- static: yes, type: i32, effect: none
// memindex1353 -- static: yes, type: i32, effect: none
// arg13401364 -- static: no, type: f64, effect: none
// eff13411375 -- static: no, type: <bottom>, effect: memory
// cond13471358 -- static: no, type: <bottom>, effect: none
// index1363 -- static: no, type: i64, effect: pop
// arg13481357 -- static: no, type: <bottom>, effect: none
// arg13391365 -- static: yes, type: i64, effect: none
// arg13381366 -- static: no, type: i64, effect: none
// arg13371367 -- static: yes, type: i32, effect: none
// index1370 -- static: no, type: i32, effect: pop
// arg13491354 -- static: yes, type: <bottom>, effect: none
// eff13361368 -- static: no, type: <bottom>, effect: memory
// offset1369 -- static: yes, type: i32, effect: read
// val1359 -- static: no, type: f64, effect: pop

	def flags = imm_readU8();
	def val = pop_f64();
	def cond = m_isMemory64(0u);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_f64(0u, index, offset, val);
	} else {
		def offset1 = imm_readULEB32();
		def index1 = pop_u32();
		mach_writeMemory32_f64(0u, index1, offset1, val);
	}
}
def build_dispatch_table() -> Array<void -> void> {
  DISPATCH_TABLE = Array.new(0xE5 + 1);
  for (i < 0xE5 + 1) DISPATCH_TABLE[i] = trapUnreachable;
  DISPATCH_TABLE[Opcode.UNREACHABLE.tag] = UNREACHABLE;
  DISPATCH_TABLE[Opcode.NOP.tag] = NOP;
  DISPATCH_TABLE[Opcode.LOCAL_GET.tag] = LOCAL_GET;
  DISPATCH_TABLE[Opcode.LOCAL_SET.tag] = LOCAL_SET;
  DISPATCH_TABLE[Opcode.LOCAL_TEE.tag] = LOCAL_TEE;
  DISPATCH_TABLE[Opcode.GLOBAL_GET.tag] = GLOBAL_GET;
  DISPATCH_TABLE[Opcode.GLOBAL_SET.tag] = GLOBAL_SET;
  DISPATCH_TABLE[Opcode.TABLE_GET.tag] = TABLE_GET;
  DISPATCH_TABLE[Opcode.TABLE_SET.tag] = TABLE_SET;
  DISPATCH_TABLE[Opcode.CALL.tag] = CALL;
  DISPATCH_TABLE[Opcode.CALL_INDIRECT.tag] = CALL_INDIRECT;
  DISPATCH_TABLE[Opcode.RETURN_CALL.tag] = RETURN_CALL;
  DISPATCH_TABLE[Opcode.DROP.tag] = DROP;
  DISPATCH_TABLE[Opcode.SELECT.tag] = SELECT;
  DISPATCH_TABLE[Opcode.I32_CONST.tag] = I32_CONST;
  DISPATCH_TABLE[Opcode.I32_ADD.tag] = I32_ADD;
  DISPATCH_TABLE[Opcode.I32_SUB.tag] = I32_SUB;
  DISPATCH_TABLE[Opcode.I32_MUL.tag] = I32_MUL;
  DISPATCH_TABLE[Opcode.I32_DIV_S.tag] = I32_DIV_S;
  DISPATCH_TABLE[Opcode.I32_DIV_U.tag] = I32_DIV_U;
  DISPATCH_TABLE[Opcode.I32_EQZ.tag] = I32_EQZ;
  DISPATCH_TABLE[Opcode.I32_EQ.tag] = I32_EQ;
  DISPATCH_TABLE[Opcode.I32_NE.tag] = I32_NE;
  DISPATCH_TABLE[Opcode.I32_LT_U.tag] = I32_LT_U;
  DISPATCH_TABLE[Opcode.I32_LT_S.tag] = I32_LT_S;
  DISPATCH_TABLE[Opcode.I32_LE_S.tag] = I32_LE_S;
  DISPATCH_TABLE[Opcode.I32_GT_U.tag] = I32_GT_U;
  DISPATCH_TABLE[Opcode.I32_AND.tag] = I32_AND;
  DISPATCH_TABLE[Opcode.F32_CONST.tag] = F32_CONST;
  DISPATCH_TABLE[Opcode.F32_ADD.tag] = F32_ADD;
  DISPATCH_TABLE[Opcode.F32_SUB.tag] = F32_SUB;
  DISPATCH_TABLE[Opcode.F32_MUL.tag] = F32_MUL;
  DISPATCH_TABLE[Opcode.F32_DIV.tag] = F32_DIV;
  DISPATCH_TABLE[Opcode.F32_SQRT.tag] = F32_SQRT;
  DISPATCH_TABLE[Opcode.F32_EQ.tag] = F32_EQ;
  DISPATCH_TABLE[Opcode.F32_NE.tag] = F32_NE;
  DISPATCH_TABLE[Opcode.F32_LT.tag] = F32_LT;
  DISPATCH_TABLE[Opcode.F32_LE.tag] = F32_LE;
  DISPATCH_TABLE[Opcode.F32_GT.tag] = F32_GT;
  DISPATCH_TABLE[Opcode.BR.tag] = BR;
  DISPATCH_TABLE[Opcode.BR_IF.tag] = BR_IF;
  DISPATCH_TABLE[Opcode.BLOCK.tag] = BLOCK;
  DISPATCH_TABLE[Opcode.LOOP.tag] = LOOP;
  DISPATCH_TABLE[Opcode.TRY.tag] = TRY;
  DISPATCH_TABLE[Opcode.IF.tag] = IF;
  DISPATCH_TABLE[Opcode.ELSE.tag] = ELSE;
  DISPATCH_TABLE[Opcode.END.tag] = END;
  DISPATCH_TABLE[Opcode.RETURN.tag] = RETURN;
  DISPATCH_TABLE[Opcode.REF_NULL.tag] = REF_NULL;
  DISPATCH_TABLE[Opcode.REF_IS_NULL.tag] = REF_IS_NULL;
  DISPATCH_TABLE[Opcode.REF_AS_NON_NULL.tag] = REF_AS_NON_NULL;
  DISPATCH_TABLE[Opcode.STRUCT_NEW.tag] = STRUCT_NEW;
  DISPATCH_TABLE[Opcode.STRUCT_GET.tag] = STRUCT_GET;
  DISPATCH_TABLE[Opcode.STRUCT_GET_S.tag] = STRUCT_GET_S;
  DISPATCH_TABLE[Opcode.STRUCT_GET_U.tag] = STRUCT_GET_U;
  DISPATCH_TABLE[Opcode.I32_LOAD.tag] = I32_LOAD;
  DISPATCH_TABLE[Opcode.I32_LOAD8_U.tag] = I32_LOAD8_U;
  DISPATCH_TABLE[Opcode.I32_LOAD16_S.tag] = I32_LOAD16_S;
  DISPATCH_TABLE[Opcode.I64_LOAD.tag] = I64_LOAD;
  DISPATCH_TABLE[Opcode.F32_LOAD.tag] = F32_LOAD;
  DISPATCH_TABLE[Opcode.F64_LOAD.tag] = F64_LOAD;
  DISPATCH_TABLE[Opcode.I32_STORE.tag] = I32_STORE;
  DISPATCH_TABLE[Opcode.I32_STORE8.tag] = I32_STORE8;
  DISPATCH_TABLE[Opcode.I32_STORE16.tag] = I32_STORE16;
  DISPATCH_TABLE[Opcode.I64_STORE.tag] = I64_STORE;
  DISPATCH_TABLE[Opcode.F32_STORE.tag] = F32_STORE;
  DISPATCH_TABLE[Opcode.F64_STORE.tag] = F64_STORE;
  return DISPATCH_TABLE;
}
type STEntry {
    case Is64(
        is64: int
    );
    case Label(
        label: int
    );
    case KindOffset(
        kind: int,
        offset: int
    );
}
var module: Module;
var codeptr: CodePtr;
var opcode: Opcode;
var opcode_pos: int; // not used much, because interpreter uses codeptr.pos
var DISPATCH_TABLE: Array<void -> void> = build_dispatch_table();
var local_types: Vector<TypeVar>;
var stack: ArrayStack<TypeVar>;
var globals: Vector<TypeVar>;
var rets: Array<TypeVar>;

// steal sidetable stuff from existing validator,
// to support custom sidetable stuff I think we can keep ControlEntry but replace SidetableBuilder
var ctl_stack: ArrayStack<ControlEntry>;
var ctlxfer: SidetableBuilder;
var ctl_top: ControlEntry;

// stolen from CodeValidator.v3
def pushControl(opcode: u16, params: Array<ValueType>, results: Array<ValueType>, val_stack_top: int) -> ControlEntry {
    var ctl = ctl_stack.next();
    if (ctl != null) { // FAST: reuse previous ControlEntry object
        ctl_stack.top++;
    } else { // allocate and cache new ControlEntry object
        ctl = ControlEntry.new();
        ctl_stack.push(ctl);
    }
    ctl_top = ctl;
    ctl.start_pos = codeptr.pos;
    ctl.delegate_pos = codeptr.pos;
    ctl.start_opcode = opcode;
    ctl.sidetable_pos = -1;
    ctl.params = params;
    ctl.results = results;
    ctl.val_stack_top = val_stack_top;
    ctl.reachable = true;
    ctl.first_ref = -1;
    ctl.else_ref = -1;
    ctl.undo_init_list = null;
    return ctl;
}

def popTypes(ts: Array<ValueType>) {
    for (i = ts.length - 1; i >= 0; i -= 1) pop_Value(typeVarFromValType(ts[i]));
}

def pushTypes(ts: Array<ValueType>) {
    for (i < ts.length) push_Value(typeVarFromValType(ts[i]), typeVarFromValType(ts[i]));
}

// Constants
def HAS_MEM_INDEX = 0x40u8;

// Types.
type v128(low: u64, high: u64);

// goofy way to avoid having to impl every operator
// but still specialize type and show the called operator in the generated code
def gen_binop<C, R>(op: (C, C) -> C) -> (R, R) -> R { 
    return fun (lhs: R, rhs: R) => lhs; 
}
def gen_testop<C, R>(op: (C, C) -> bool) -> (R, R) -> R { 
    return fun (lhs: R, rhs: R) => lhs; 
}
type TypeVar {
    case U32 {
        def binop(op: (u32, u32) -> u32) => gen_binop<u32, TypeVar.U32>(op);
        def testop(op: (u32, u32) -> bool) => gen_testop<u32, TypeVar.U32>(op);
    }
    case U64 {
        def binop(op: (u64, u64) -> u64) => gen_binop<u64, TypeVar.U64>(op);
        def testop(op: (u64, u64) -> bool) => gen_testop<u64, TypeVar.U64>(op);
    }
    case F32 {
        def binop(op: (float, float) -> float) => gen_binop<float, TypeVar.F32>(op);
        def testop(op: (float, float) -> bool) => gen_testop<float, TypeVar.F32>(op);
    }
    case F64 {
        def binop(op: (double, double) -> double) => gen_binop<double, TypeVar.F64>(op);
        def testop(op: (double, double) -> bool) => gen_testop<double, TypeVar.F64>(op);
    }
    case V128 {
        def binop(op: (v128, v128) -> v128) => gen_binop<v128, TypeVar.V128>(op);
        def testop(op: (v128, v128) -> bool) => gen_testop<v128, TypeVar.V128>(op);
    }
    case Object {
        def binop(op: (Object, Object) -> Object) => gen_binop<Object, TypeVar.Object>(op);
        def testop(op: (Object, Object) -> bool) => gen_testop<Object, TypeVar.Object>(op);
    }
    case Err;
    case Bot;

    def unbox_u32() -> TypeVar.U32 {
        if (TypeVar.U32.?(this)) return TypeVar.U32;
        return invalid_t(TypeVar.U32);
    }

    def unbox_u64() -> TypeVar.U64 {
        if (TypeVar.U64.?(this)) return TypeVar.U64;
        return invalid_t(TypeVar.U64);
    }
    
    def unbox_f32() -> TypeVar.F32 {
        if (TypeVar.F32.?(this)) return TypeVar.F32;
        return invalid_t(TypeVar.F32);
    }
    
    def unbox_f64() -> TypeVar.F64 {
        if (TypeVar.F64.?(this)) return TypeVar.F64;
        return invalid_t(TypeVar.F64);
    }
    
    def unbox_v128() -> TypeVar.V128 {
        if (TypeVar.V128.?(this)) return TypeVar.V128;
        return invalid_t(TypeVar.V128);
    }
    
    def unbox_Object() -> TypeVar.Object {
        if (TypeVar.Object.?(this)) return TypeVar.Object;
        return invalid_t(TypeVar.Object);
    }
    
    def matches(other: TypeVar) -> bool {
        return this == other;
    }

    def short_str() -> string {
        match (this) {
            U32 => return "u";
            U64 => return "l";
            F32 => return "f";
            F64 => return "d";
            V128 => return "v";
            Object => return "r";
            Err => return "err";
            Bot => return "V";
        }
    }

    def long_str() -> string {
        match (this) {
            U32 => return "u32";
            U64 => return "u64";
            F32 => return "f32";
            F64 => return "f64";
            V128 => return "v128";
            Object => return "Ref";
            Err => return "Err";
            Bot => return "Value";
        }
    }
}

def U32_equals = TypeVar.U32.testop(u32.==);
def U32_not_equals = TypeVar.U32.testop(u32.!=);
def U32_plus = TypeVar.U32.binop(u32.+);
def U32_minus = TypeVar.U32.binop(u32.-);
def U32_div = TypeVar.U32.binop(u32./);
def U32_lt = TypeVar.U32.testop(u32.<);
def U32_lte = TypeVar.U32.testop(u32.<=);
def U32_gt = TypeVar.U32.testop(u32.>);
def U32_times = TypeVar.U32.binop(u32.*);
def U32_and = TypeVar.U32.binop(u32.&);

def F32_equals = TypeVar.F32.testop(float.==);
def F32_not_equals = TypeVar.F32.testop(float.==);
def F32_lt = TypeVar.F32.testop(float.<);
def F32_lte = TypeVar.F32.testop(float.<=);
def F32_gt = TypeVar.F32.testop(float.>);
def F32_plus = TypeVar.F32.binop(float.+);
def F32_minus = TypeVar.F32.binop(float.-);
def F32_div = TypeVar.F32.binop(float./);
def F32_times = TypeVar.F32.binop(float.*);
def F32_sqrt = fun (x: TypeVar.F32) => x;

def object_Null() -> TypeVar.Object => TypeVar.Object;
def object_isNull(o: TypeVar.Object) => true;
def object_New(sig: HeapTypeDecl) -> TypeVar.Object => TypeVar.Object;

def typeVarFromValType(vt: ValueType) -> TypeVar {
    match (vt) {
        I32 => return TypeVar.U32;
        I64 => return TypeVar.U64;
        F32 => return TypeVar.F32;
        F64 => return TypeVar.F64;
        V128 => return TypeVar.V128;
        Ref => return TypeVar.Object;
        Host => return TypeVar.Object;
        BOTTOM => return TypeVar.Bot;
    }
}

def valTypeFromTypeVar(tv: TypeVar) -> ValueType {
    match (tv) {
        U32 => return ValueType.I32;
        U64 => return ValueType.I64;
        F32 => return ValueType.F32;
        F64 => return ValueType.F64;
        V128 => return ValueType.V128;
        Object => return ValueTypes.ANYREF;
        Err => return ValueType.BOTTOM;
        Bot => return ValueType.BOTTOM;
    }
}

def invalid_t<T>(t: T) -> T {
    invalid();
    return t;
}

def rtcast_u32(x: u32) -> TypeVar.U32 {
    return TypeVar.U32;
}
def rtcast_i32 = rtcast_u32;
def rtcast_f32(x: float) -> TypeVar.F32 {
    return TypeVar.F32;
}

type FieldOffset(offset: u32);
enum FieldKind {
    U8, U16, U32, U64, F32, F64, V128, REF
}

def imm_readULEB32() -> u32 => codeptr.read_uleb32();
def imm_readULEB64() -> u64 => codeptr.read_uleb64();

def imm_readILEB32() -> u32 => u32.view(codeptr.read_sleb32());
def imm_readILEB64() -> u64 => u32.view(codeptr.read_sleb64());

def imm_readU8() -> u8 {
    return codeptr.read1();
}

def imm_readBlockType() -> (Array<ValueType>, Array<ValueType>) {
    def bt = codeptr.read_BlockTypeCode();
    return bt.toAbstractBlockType(module);
}

def pop_u32() -> TypeVar.U32 {
    return stack.pop().unbox_u32();
}
def pop_u64() -> TypeVar.U64 {
    return stack.pop().unbox_u64();
}
def pop_f32() -> TypeVar.F32 {
    return stack.pop().unbox_f32();
}
def pop_f64() -> TypeVar.F64 {
    return stack.pop().unbox_f64();
}
def pop_v128() -> TypeVar.V128 {
    return stack.pop().unbox_v128();
}
def pop_Object() -> TypeVar.Object {
    return stack.pop().unbox_Object();
}
def pop_Value(tv: TypeVar) -> TypeVar {
    def actual = stack.pop();
    if (tv.matches(actual)) return tv;
    return invalid_t(tv);
}

def push_u32(v: TypeVar.U32) {
    stack.push(v);
}
def push_u64(v: TypeVar.U64) {
    stack.push(TypeVar.U64);
}
def push_f32(v: TypeVar.F32) {
    stack.push(TypeVar.F32);
}
def push_f64(v: TypeVar.F64) {
    stack.push(TypeVar.F64);
}
def push_v128(v: TypeVar.V128) {
    stack.push(TypeVar.V128);
}
def push_Object(v: TypeVar.Object) {
    stack.push(v);
}
def push_Value(tv: TypeVar, v: TypeVar) {
    if (!tv.matches(v)) invalid();
    stack.push(tv);
}

// Local variables.
def getLocal(tv: TypeVar, index: u32) -> TypeVar {
    if (!tv.matches(stack.elems[index])) invalid();
    return tv;
}
def setLocal(tv: TypeVar, index: u32, v: TypeVar) {
    if (!tv.matches(v)) invalid();
    stack.elems[index] = tv;
}

// Global variables.
def getGlobal(tv: TypeVar, index: u32) -> TypeVar {
    return globals[int.view(index)];
}
def setGlobal(tv: TypeVar, index: u32, v: TypeVar) {
    globals[int.view(index)] = v;
}

// Function context.
def f_getLabel(depth: u32) -> ControlEntry {
    return ctl_stack.elems[ctl_stack.top - int.view(depth) - 1];
}

def f_getLocalType(index: u32) -> TypeVar {
    return local_types[int.view(index)];
}

def f_getTopOfStackType() -> TypeVar {
    return stack.peek();
}

// Module context.
def m_getGlobalType(index: u32) -> TypeVar {
    return globals[int.view(index)];
}
def m_getFieldKind(struct_index: u32, field_index: u32) -> FieldKind {
    def ht = module.heaptypes[int.view(struct_index)];
    def decl = StructDecl.!(ht);
    def st = decl.field_types[field_index];
    match (st.valtype) {
        BOTTOM => return FieldKind.REF;
        I32 => return FieldKind.U32;
        I64 => return FieldKind.U64;
        F32 => return FieldKind.F32;
        F64 => return FieldKind.F64;
        V128 => return FieldKind.V128;
        Host => return FieldKind.REF;
        Ref => return FieldKind.REF;
    }
}
def m_getFieldOffset(struct_index: u32, field_index: u32) -> FieldOffset {
    return FieldOffset(u32.!(field_index)); // TODO
}
def m_isMemory64(memory_index: u32) -> bool => false; // TODO mem64
def m_isTable64(memory_index: u32) -> bool => false;
def m_getFuncSignature(func_index: u32) -> SigDecl {
    return null;
}
def m_getSignature(sig_index: u32) -> HeapTypeDecl {
    return module.heaptypes[int.view(sig_index)];
}

// Instance context.
def i_getTableFunction64(table_index: u32, sig: Decl, func_index: TypeVar.U64) -> CBDFunction;
def i_getTableFunction32(table_index: u32, sig: Decl, func_index: TypeVar.U32) -> CBDFunction;
def i_getFunction(func_index: u32) => CBDFunction.new(module.functions[int.view(func_index)]);

// Control flow.
def doCall(sig: Decl, target: CBDFunction) {
    for (i = target.args.length - 1; i >= 0; i -= 1) pop_Value(target.args[i]);
    for (i < target.rets.length) push_Value(target.rets[i], target.rets[i]);
}

def doReturnCall = doCall;

def doBranch(label: ControlEntry) {
    ctlxfer.refS(label, codeptr.pos, stack.top);
    def args = if(label.start_opcode == Opcode.LOOP.code, label.params, label.results);
    popTypes(args);
    pushTypes(args);
}

def doFallthru() {
}

// Machine intrinsics.
def mach_readStructField_u8(obj: TypeVar.Object, offset: FieldOffset) => TypeVar.U32;
def mach_readStructField_u16(obj: TypeVar.Object, offset: FieldOffset) => TypeVar.U32;
def mach_readStructField_u32(obj: TypeVar.Object, offset: FieldOffset) => TypeVar.U32;
def mach_readStructField_u64(obj: TypeVar.Object, offset: FieldOffset) => TypeVar.U64;
def mach_readStructField_f32(obj: TypeVar.Object, offset: FieldOffset) => TypeVar.F32;
def mach_readStructField_f64(obj: TypeVar.Object, offset: FieldOffset) => TypeVar.F64;
def mach_readStructField_v128(obj: TypeVar.Object, offset: FieldOffset) => TypeVar.V128;
def mach_readStructField_Object(obj: TypeVar.Object, offset: FieldOffset) => TypeVar.Object;

// TODO: validate read/write
def mach_readMemory64_u8(memory_index: u32, index: TypeVar.U64, offset: u64) => TypeVar.U32;
def mach_readMemory32_u8(memory_index: u32, index: TypeVar.U32, offset: u32) => TypeVar.U32;
def mach_readMemory64_u16(memory_index: u32, index: TypeVar.U64, offset: u64) => TypeVar.U32;
def mach_readMemory32_u16(memory_index: u32, index: TypeVar.U32, offset: u32) => TypeVar.U32;
def mach_readMemory64_u32(memory_index: u32, index: TypeVar.U64, offset: u64) => TypeVar.U32;
def mach_readMemory32_u32(memory_index: u32, index: TypeVar.U32, offset: u32) => TypeVar.U32;
def mach_readMemory64_u64(memory_index: u32, index: TypeVar.U64, offset: u64) => TypeVar.U64;
def mach_readMemory32_u64(memory_index: u32, index: TypeVar.U32, offset: u32) => TypeVar.U64;
def mach_readMemory64_f32(memory_index: u32, index: TypeVar.U64, offset: u64) => TypeVar.F32;
def mach_readMemory32_f32(memory_index: u32, index: TypeVar.U32, offset: u32) => TypeVar.F32;
def mach_readMemory64_f64(memory_index: u32, index: TypeVar.U64, offset: u64) => TypeVar.F64;
def mach_readMemory32_f64(memory_index: u32, index: TypeVar.U32, offset: u32) => TypeVar.F64;

def mach_writeMemory64_u8(memory_index: u32, index: TypeVar.U64, offset: u64, val: TypeVar.U32) => void;
def mach_writeMemory32_u8(memory_index: u32, index: TypeVar.U32, offset: u32, val: TypeVar.U32) => void;
def mach_writeMemory64_u16(memory_index: u32, index: TypeVar.U64, offset: u64, val: TypeVar.U32) => void;
def mach_writeMemory32_u16(memory_index: u32, index: TypeVar.U32, offset: u32, val: TypeVar.U32) => void;
def mach_writeMemory64_u32(memory_index: u32, index: TypeVar.U64, offset: u64, val: TypeVar.U32) => void;
def mach_writeMemory32_u32(memory_index: u32, index: TypeVar.U32, offset: u32, val: TypeVar.U32) => void;
def mach_writeMemory64_u64(memory_index: u32, index: TypeVar.U64, offset: u64, val: TypeVar.U64) => void;
def mach_writeMemory32_u64(memory_index: u32, index: TypeVar.U32, offset: u32, val: TypeVar.U64) => void;
def mach_writeMemory64_f32(memory_index: u32, index: TypeVar.U64, offset: u64, val: TypeVar.F32) => void;
def mach_writeMemory32_f32(memory_index: u32, index: TypeVar.U32, offset: u32, val: TypeVar.F32) => void;
def mach_writeMemory64_f64(memory_index: u32, index: TypeVar.U64, offset: u64, val: TypeVar.F64) => void;
def mach_writeMemory32_f64(memory_index: u32, index: TypeVar.U32, offset: u32, val: TypeVar.F64) => void;

def mach_readTable64(table_index: u32, index: TypeVar.U64) => TypeVar.Object;
def mach_readTable32(table_index: u32, index: TypeVar.U32) => TypeVar.Object;

def mach_writeTable64(table_index: u32, index: TypeVar.U64, val: TypeVar.Object) => void;
def mach_writeTable32(table_index: u32, index: TypeVar.U32, val: TypeVar.Object) => void;

// Traps.
def invalid();
def trapNull() {
    // since this is a runtime trap only, 
    // we don't actually want to trap here
}
def trapUnreachable() {} // XXX: validator tries to validate unreachable code
def trapDivideByZero();
def trapDivideUnrepresentable();
def trapTableOOB();

def doBlock(bt: (Array<ValueType>, Array<ValueType>)) -> ControlEntry {
    def args = bt.0;
    def rets = bt.1;
    popTypes(args);
    pushTypes(args);
    pushControl(Opcode.BLOCK.code, args, rets, stack.top);
    return ctl_top;
}

def doLoop(bt: (Array<ValueType>, Array<ValueType>)) -> ControlEntry {
    def args = bt.0;
    def rets = bt.1;
    popTypes(args);
    pushTypes(args);
    pushControl(Opcode.LOOP.code, args, rets, stack.top);
    ctl_top.sidetable_pos = ctlxfer.sidetable.length;
    return ctl_top;
}

def doIf(bt: (Array<ValueType>, Array<ValueType>)) -> ControlEntry {
    def args = bt.0;
    def rets = bt.1;
    popTypes(args);
    pushTypes(args);
    def ctl = pushControl(Opcode.IF.code, args, rets, stack.top);
    ctlxfer.refElse(ctl, codeptr.pos);
    return ctl;
}

def doElse() -> ControlEntry {
	if (ctl_top.start_opcode != Opcode.IF.code) invalid();
    def p = ctl_top.results;
    popTypes(p);
    stack.top = ctl_top.val_stack_top;
    pushTypes(p);
    ctlxfer.ref0(ctl_top, codeptr.pos);
    ctlxfer.bindElse(ctl_top, codeptr.pos);

    ctl_top.start_opcode = opcode.code;
    ctl_top.reachable = true;
    stack.top = ctl_top.val_stack_top;
    pushTypes(ctl_top.params);

    return ctl_top;
}

def doEnd() {
    def p = ctl_top.results;
    popTypes(p);
    stack.top = ctl_top.val_stack_top;
    pushTypes(p);
    match (ctl_top.start_opcode) {
        Opcode.LOOP.code => {
            ctlxfer.bind(ctl_top, ctl_top.start_pos, ctl_top.sidetable_pos);
        }
        Opcode.IF.code => {
            // one-armed if; simulate an empty else clause
            stack.top = ctl_top.val_stack_top;
            ctl_top.reachable = true;
            pushTypes(ctl_top.params);
            popTypes(ctl_top.results);
            ctlxfer.bindElse(ctl_top, codeptr.pos);
            ctlxfer.bind(ctl_top, codeptr.pos, ctlxfer.sidetable.length);
        }
        _ => {
            ctlxfer.bind(ctl_top, codeptr.pos, ctlxfer.sidetable.length);
        }
    }
    ctl_stack.pop();
    ctl_top = ctl_stack.peek();
}

def doReturn() {
    for (i = rets.length - 1; i >= 0; i -= 1) pop_Value(rets[i]);
    for (i < rets.length) push_Value(rets[i], rets[i]);
}

def doTry(bt: (Array<ValueType>, Array<ValueType>)) {
    return;
}

def f_isAtEnd() -> bool {
    return codeptr.pos >= codeptr.data.length;
}

def f32_reinterpret_u32(i: TypeVar.U32) -> TypeVar.F32;
def f64_reinterpret_u64(i: TypeVar.U64) -> TypeVar.F64;
def u32_reinterpret_f32(f: TypeVar.F32) -> TypeVar.U32;
def u64_reinterpret_f64(f: TypeVar.F64) -> TypeVar.U64;

def u32_div_s(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def u32_lt_s(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def u32_le_s(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;

def push_locals(count: u32, vtc: ValueTypeCode) {
    var tv: TypeVar;
    match (vtc.code) {
        BpTypeCode.I32.val => tv = TypeVar.U32;
        BpTypeCode.I64.val => tv = TypeVar.U64;
        BpTypeCode.F32.val => tv = TypeVar.F32;
        BpTypeCode.F64.val => tv = TypeVar.F64;
        BpTypeCode.V128.val => tv = TypeVar.V128;
        BpTypeCode.FUNCREF.val => tv = TypeVar.Object;
        BpTypeCode.EXTERNREF.val => tv = TypeVar.Object;
        BpTypeCode.ANYREF.val => tv = TypeVar.Object;
        BpTypeCode.EQREF.val => tv = TypeVar.Object;
        BpTypeCode.I31REF.val => tv = TypeVar.Object;
        BpTypeCode.STRUCTREF.val => tv = TypeVar.Object;
        BpTypeCode.ARRAYREF.val => tv = TypeVar.Object;
        _ => tv = TypeVar.Object; // default to Object for unknown ref types
    }
 
    for (i < count) local_types.put(tv);
    for (i < count) stack.push(tv);
}

component Validator {
    def init(new_module: Module, args: Array<int>) {
        module = new_module;
        
        globals = Vector.new();
        for (i < module.globals.length) {
            def module_global = module.globals[i];
            var global_type = typeVarFromValType(module_global.valtype);
            globals.put(global_type);
        }
    }
    
    def init_function(code: Array<byte>, args: Array<TypeVar>, locals: Array<TypeVar>, ret: Array<TypeVar>) {
        codeptr = CodePtr.new(code);
        local_types = Vector.new();
        stack = ArrayStack.new();

        ctl_stack = ArrayStack.new();
        ctlxfer = CBDSidetableBuilder.new();
        ctl_top = null;

        opcode_pos = codeptr.pos;
        pushControl(Opcode.UNREACHABLE.code, Arrays.map(args, valTypeFromTypeVar), Arrays.map(ret, valTypeFromTypeVar), 0);

        for (a in args) local_types.put(a);
        for (a in args) stack.push(a);

        rets = ret;
    }

    def dispatch() {
        codeptr.iterate_local_codes(push_locals);
        ctlxfer.reset(codeptr.pos);
        while (codeptr.pos < codeptr.data.length) {
            opcode_pos = codeptr.pos;
            opcode = codeptr.read_opcode();
            System.puts(opcode.mnemonic);
            System.ln();
            DISPATCH_TABLE[opcode.tag]();
        }
    }

    def build_sidetable() -> Sidetable {
        return ctlxfer.extract();
    }
}

class CBDSidetableBuilder extends SidetableBuilder {
}
