// GENERATED BY ValidatorGen.v3
def UNREACHABLE() {
	trapUnreachable();
}
def NOP() {
}
def LOCAL_GET() {
	def index = imm_readULEB32();
	def tv = f_getLocalType(index);
	def val = getLocal(tv, index);
	push_Value(tv, val);
}
def LOCAL_SET() {
	def index = imm_readULEB32();
	def tv = f_getLocalType(index);
	def val = pop_Value(tv);
	setLocal(tv, index, val);
}
def LOCAL_TEE() {
	def index = imm_readULEB32();
	def tv = f_getLocalType(index);
	def val = pop_Value(tv);
	push_Value(tv, val);
	setLocal(tv, index, val);
}
def GLOBAL_GET() {
	def index = imm_readULEB32();
	def tv = m_getGlobalType(index);
	def val = getGlobal(tv, index);
	push_Value(tv, val);
}
def GLOBAL_SET() {
	def index = imm_readULEB32();
	def tv = m_getGlobalType(index);
	def val = pop_Value(tv);
	setGlobal(tv, index, val);
}
def TABLE_GET() {
	def table_index = imm_readULEB32();
	def cond = m_isTable64(table_index);
	if (cond) {
		def index = pop_u64();
		def val = mach_readTable64(table_index, index);
		push_Object(val);
	} else {
		def index = pop_u32();
		def val = mach_readTable32(table_index, index);
		push_Object(val);
	}
}
def TABLE_SET() {
	def table_index = imm_readULEB32();
	def cond = m_isTable64(table_index);
	if (cond) {
		def val = pop_Object();
		def index = pop_u64();
	} else {
		def val = pop_Object();
		def index = pop_u32();
	}
}
def CALL() {
	def index = imm_readULEB32();
	def sig = m_getFuncSignature(index);
	def target = i_getFunction(index);
	doCall(sig, target);
}
def CALL_INDIRECT() {
	def sig_index = imm_readULEB32();
	def sig = m_getSignature(sig_index);
	def table_index = imm_readULEB32();
	def is64 = m_isTable64(table_index);
	if (is64) {
		def func_index = pop_u64();
		def target = i_getTableFunction64(table_index, sig, func_index);
		doCall(sig, target);
	} else {
		def func_index = pop_u32();
		def target = i_getTableFunction32(table_index, sig, func_index);
		doCall(sig, target);
	}
	if (is64) {
		def func_index = pop_u64();
		def target = i_getTableFunction64(table_index, sig, func_index);
		doCall(sig, target);
	} else {
		def func_index = pop_u32();
		def target = i_getTableFunction32(table_index, sig, func_index);
		doCall(sig, target);
	}
	ctlxfer.put_CALL_INDIRECT(is64);
}
def RETURN_CALL() {
	def index = imm_readULEB32();
	def sig = m_getFuncSignature(index);
	def target = i_getFunction(index);
	doReturnCall(sig, target);
}
def DROP() {
	def tv = f_getTopOfStackType();
	pop_Value(tv);
}
def SELECT() {
	def tv = f_getTopOfStackType();
	def c = pop_u32();
	def b = pop_Value(tv);
	def a = pop_Value(tv);
	push_Value(tv, a);
	push_Value(tv, b);
}
def I32_CONST() {
	def x = imm_readILEB32();
	push_u32(rtcast_u32(x));
}
def I32_ADD() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_plus(a, b));
}
def I32_SUB() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_minus(a, b));
}
def I32_MUL() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_times(a, b));
}
def I32_DIV_S() {
	def b = pop_u32();
	def a = pop_u32();
	trapDivideByZero();
	trapDivideUnrepresentable();
	push_u32(U32_div_s(a, b));
}
def I32_DIV_U() {
	def b = pop_u32();
	def a = pop_u32();
	trapDivideByZero();
	push_u32(U32_div(a, b));
}
def I32_EQZ() {
	def a = pop_u32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I32_EQ() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I32_NE() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I32_LT_U() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I32_LT_S() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I32_LE_S() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I32_GT_U() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I32_LE_U() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I32_GT_S() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I32_GE_U() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I32_GE_S() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I32_AND() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_and(a, b));
}
def I32_OR() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_or(a, b));
}
def I32_XOR() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_or(a, b));
}
def I32_SHL() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_shl(a, b));
}
def I32_SHR_U() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_shr_u(a, b));
}
def I32_SHR_S() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_shr_s(a, b));
}
def I32_ROTL() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_rotl(a, b));
}
def I32_ROTR() {
	def b = pop_u32();
	def a = pop_u32();
	push_u32(U32_rotr(a, b));
}
def I32_CLZ() {
	def a = pop_u32();
	push_u32(U32_clz(a));
}
def I32_CTZ() {
	def a = pop_u32();
	push_u32(U32_ctz(a));
}
def I32_POPCNT() {
	def a = pop_u32();
	push_u32(U32_popcnt(a));
}
def I32_REM_S() {
	def b = pop_u32();
	def a = pop_u32();
	trapDivideByZero();
	push_u32(U32_rem_s(a, b));
}
def I32_REM_U() {
	def b = pop_u32();
	def a = pop_u32();
	trapDivideByZero();
	push_u32(U32_rem_u(a, b));
}
def I32_EXTEND8_S() {
	def a = pop_u32();
	def r = U32_extend8_s(a);
	push_u32(r);
}
def I32_EXTEND16_S() {
	def a = pop_u32();
	def r = U32_extend16_s(a);
	push_u32(r);
}
def I64_CONST() {
	def x = imm_readILEB64();
	push_u64(rtcast_u64(x));
}
def I64_ADD() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_plus(a, b));
}
def I64_SUB() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_minus(a, b));
}
def I64_MUL() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_times(a, b));
}
def I64_DIV_S() {
	def b = pop_u64();
	def a = pop_u64();
	trapDivideByZero();
	trapDivideUnrepresentable();
	push_u64(U64_div_s(a, b));
}
def I64_DIV_U() {
	def b = pop_u64();
	def a = pop_u64();
	trapDivideByZero();
	push_u64(U64_div(a, b));
}
def I64_REM_S() {
	def b = pop_u64();
	def a = pop_u64();
	trapDivideByZero();
	push_u64(U64_rem_s(a, b));
}
def I64_REM_U() {
	def b = pop_u64();
	def a = pop_u64();
	trapDivideByZero();
	push_u64(U64_rem_u(a, b));
}
def I64_AND() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_and(a, b));
}
def I64_OR() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_or(a, b));
}
def I64_XOR() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_or(a, b));
}
def I64_SHL() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_shl(a, b));
}
def I64_SHR_U() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_shr_u(a, b));
}
def I64_SHR_S() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_shr_s(a, b));
}
def I64_ROTL() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_rotl(a, b));
}
def I64_ROTR() {
	def b = pop_u64();
	def a = pop_u64();
	push_u64(U64_rotr(a, b));
}
def I64_CLZ() {
	def a = pop_u64();
	push_u64(U64_clz(a));
}
def I64_CTZ() {
	def a = pop_u64();
	push_u64(U64_ctz(a));
}
def I64_POPCNT() {
	def a = pop_u64();
	push_u64(U64_popcnt(a));
}
def I64_EQZ() {
	def a = pop_u64();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I64_EQ() {
	def b = pop_u64();
	def a = pop_u64();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I64_NE() {
	def b = pop_u64();
	def a = pop_u64();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I64_LT_S() {
	def b = pop_u64();
	def a = pop_u64();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I64_LT_U() {
	def b = pop_u64();
	def a = pop_u64();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I64_LE_S() {
	def b = pop_u64();
	def a = pop_u64();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I64_LE_U() {
	def b = pop_u64();
	def a = pop_u64();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I64_GT_S() {
	def b = pop_u64();
	def a = pop_u64();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I64_GT_U() {
	def b = pop_u64();
	def a = pop_u64();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I64_GE_S() {
	def b = pop_u64();
	def a = pop_u64();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I64_GE_U() {
	def b = pop_u64();
	def a = pop_u64();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def I64_EXTEND8_S() {
	def a = pop_u64();
	def r = U64_extend8_s(a);
	push_u64(r);
}
def I64_EXTEND16_S() {
	def a = pop_u64();
	def r = U64_extend16_s(a);
	push_u64(r);
}
def I64_EXTEND32_S() {
	def a = pop_u64();
	def r = U64_extend32_s(a);
	push_u64(r);
}
def F32_CONST() {
	def x = imm_readULEB32();
	def arg = f32_reinterpret_u32(rtcast_u32(x));
	push_f32(arg);
}
def F32_ADD() {
	def b = pop_f32();
	def a = pop_f32();
	push_f32(F32_plus(a, b));
}
def F32_SUB() {
	def b = pop_f32();
	def a = pop_f32();
	push_f32(F32_minus(a, b));
}
def F32_MUL() {
	def b = pop_f32();
	def a = pop_f32();
	push_f32(F32_times(a, b));
}
def F32_DIV() {
	def b = pop_f32();
	def a = pop_f32();
	trapDivideByZero();
	push_f32(F32_div(a, b));
}
def F32_SQRT() {
	def a = pop_f32();
	push_f32(F32_sqrt(a));
}
def F32_EQ() {
	def b = pop_f32();
	def a = pop_f32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def F32_NE() {
	def b = pop_f32();
	def a = pop_f32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def F32_LT() {
	def b = pop_f32();
	def a = pop_f32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def F32_LE() {
	def b = pop_f32();
	def a = pop_f32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def F32_GT() {
	def b = pop_f32();
	def a = pop_f32();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def BR() {
	def depth = imm_readULEB32();
	def label = f_getLabel(depth);
	doBranch(label);
	ctlxfer.put_BR(label);
}
def BR_IF() {
	def depth = imm_readULEB32();
	def label = f_getLabel(depth);
	def cond = pop_u32();
	doBranch(label);
	doFallthru();
	ctlxfer.put_BR_IF(label);
}
def BR_TABLE() {
	def labels = imm_readLabels();
	def key = pop_u32();
	doSwitch(labels, key);
	ctlxfer.put_BR_TABLE(labels);
}
def BLOCK() {
	def bt = imm_readBlockType();
	doBlock(bt);
}
def LOOP() {
	def bt = imm_readBlockType();
	doLoop(bt);
}
def TRY() {
	def bt = imm_readBlockType();
	doTry(bt);
}
def IF() {
	def bt = imm_readBlockType();
	def cond = pop_u32();
	def label = doIf(bt);
	doBranch(label);
	doFallthru();
	ctlxfer.put_IF(label);
}
def ELSE() {
	def label = doElse();
	doBranch(label);
	ctlxfer.put_ELSE(label);
}
def END() {
	if (f_isAtEnd()) {
		doEnd();
		doReturn();
	} else {
		doEnd();
	}
}
def RETURN() {
	doReturn();
}
def REF_NULL() {
	def idx = imm_readULEB32();
	def arg = object_Null();
	push_Object(arg);
}
def REF_IS_NULL() {
	def obj = pop_Object();
	push_u32(rtcast_u32(1));
	push_u32(rtcast_u32(0));
}
def REF_AS_NON_NULL() {
	def obj = pop_Object();
	trapNull();
	push_Object(obj);
}
def STRUCT_NEW() {
	def struct_idx = imm_readULEB32();
	def sig = m_getSignature(struct_idx);
	push_Object(object_New(sig));
}
def STRUCT_GET() {
	def struct_index = imm_readULEB32();
	def field_index = imm_readULEB32();
	def obj = pop_Object();
	trapNull();
}
def STRUCT_GET_S() {
	def struct_index = imm_readULEB32();
	def field_index = imm_readULEB32();
	def obj = pop_Object();
	trapNull();
}
def STRUCT_GET_U() {
	def struct_index = imm_readULEB32();
	def field_index = imm_readULEB32();
	def obj = pop_Object();
	trapNull();
}
def I32_LOAD() {
	def flags = imm_readU8();
	var memindex: u32;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	} else {
		memindex = 0u;
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u32(memindex, index, offset);
		push_u32(val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		def val = mach_readMemory32_u32(memindex, index, offset);
		push_u32(val);
	}
}
def I32_LOAD8_U() {
	def flags = imm_readU8();
	var memindex: u32;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	} else {
		memindex = 0u;
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u8(memindex, index, offset);
		push_u32(val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		def val = mach_readMemory32_u8(memindex, index, offset);
		push_u32(val);
	}
}
def I32_LOAD16_S() {
	def flags = imm_readU8();
	var memindex: u32;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	} else {
		memindex = 0u;
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u16(memindex, index, offset);
		push_u32(val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		def val = mach_readMemory32_u16(memindex, index, offset);
		push_u32(val);
	}
}
def I64_LOAD() {
	def flags = imm_readU8();
	var memindex: u32;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	} else {
		memindex = 0u;
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_u64(memindex, index, offset);
		push_u64(val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		def val = mach_readMemory32_u64(memindex, index, offset);
		push_u64(val);
	}
}
def F32_LOAD() {
	def flags = imm_readU8();
	var memindex: u32;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	} else {
		memindex = 0u;
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_f32(memindex, index, offset);
		push_f32(val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		def val = mach_readMemory32_f32(memindex, index, offset);
		push_f32(val);
	}
}
def F64_LOAD() {
	def flags = imm_readU8();
	var memindex: u32;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	} else {
		memindex = 0u;
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		def val = mach_readMemory64_f64(memindex, index, offset);
		push_f64(val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		def val = mach_readMemory32_f64(memindex, index, offset);
		push_f64(val);
	}
}
def I32_STORE() {
	def val = pop_u32();
	def flags = imm_readU8();
	var memindex: u32;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	} else {
		memindex = 0u;
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u32(memindex, index, offset, val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		mach_writeMemory32_u32(memindex, index, offset, val);
	}
}
def I32_STORE8() {
	def val = pop_u32();
	def flags = imm_readU8();
	var memindex: u32;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	} else {
		memindex = 0u;
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u8(memindex, index, offset, val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		mach_writeMemory32_u8(memindex, index, offset, val);
	}
}
def I32_STORE16() {
	def val = pop_u32();
	def flags = imm_readU8();
	var memindex: u32;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	} else {
		memindex = 0u;
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u16(memindex, index, offset, val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		mach_writeMemory32_u16(memindex, index, offset, val);
	}
}
def I64_STORE() {
	def val = pop_u64();
	def flags = imm_readU8();
	var memindex: u32;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	} else {
		memindex = 0u;
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_u64(memindex, index, offset, val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		mach_writeMemory32_u64(memindex, index, offset, val);
	}
}
def F32_STORE() {
	def val = pop_f32();
	def flags = imm_readU8();
	var memindex: u32;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	} else {
		memindex = 0u;
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
	}
}
def F64_STORE() {
	def val = pop_f64();
	def flags = imm_readU8();
	var memindex: u32;
	if (u8.!=(u8.&(flags, 0x40u8), 0)) {
		memindex = imm_readULEB32();
	} else {
		memindex = 0u;
	}
	def cond = m_isMemory64(memindex);
	if (cond) {
		def offset = imm_readULEB64();
		def index = pop_u64();
		mach_writeMemory64_f64(memindex, index, offset, val);
	} else {
		def offset = imm_readULEB32();
		def index = pop_u32();
		mach_writeMemory32_f64(memindex, index, offset, val);
	}
}
def build_dispatch_table() -> Array<void -> void> {
  DISPATCH_TABLE = Array.new(0xE5 + 1);
  for (i < 0xE5 + 1) DISPATCH_TABLE[i] = null;
  DISPATCH_TABLE[Opcode.UNREACHABLE.tag] = UNREACHABLE;
  DISPATCH_TABLE[Opcode.NOP.tag] = NOP;
  DISPATCH_TABLE[Opcode.LOCAL_GET.tag] = LOCAL_GET;
  DISPATCH_TABLE[Opcode.LOCAL_SET.tag] = LOCAL_SET;
  DISPATCH_TABLE[Opcode.LOCAL_TEE.tag] = LOCAL_TEE;
  DISPATCH_TABLE[Opcode.GLOBAL_GET.tag] = GLOBAL_GET;
  DISPATCH_TABLE[Opcode.GLOBAL_SET.tag] = GLOBAL_SET;
  DISPATCH_TABLE[Opcode.TABLE_GET.tag] = TABLE_GET;
  DISPATCH_TABLE[Opcode.TABLE_SET.tag] = TABLE_SET;
  DISPATCH_TABLE[Opcode.CALL.tag] = CALL;
  DISPATCH_TABLE[Opcode.CALL_INDIRECT.tag] = CALL_INDIRECT;
  DISPATCH_TABLE[Opcode.RETURN_CALL.tag] = RETURN_CALL;
  DISPATCH_TABLE[Opcode.DROP.tag] = DROP;
  DISPATCH_TABLE[Opcode.SELECT.tag] = SELECT;
  DISPATCH_TABLE[Opcode.I32_CONST.tag] = I32_CONST;
  DISPATCH_TABLE[Opcode.I32_ADD.tag] = I32_ADD;
  DISPATCH_TABLE[Opcode.I32_SUB.tag] = I32_SUB;
  DISPATCH_TABLE[Opcode.I32_MUL.tag] = I32_MUL;
  DISPATCH_TABLE[Opcode.I32_DIV_S.tag] = I32_DIV_S;
  DISPATCH_TABLE[Opcode.I32_DIV_U.tag] = I32_DIV_U;
  DISPATCH_TABLE[Opcode.I32_EQZ.tag] = I32_EQZ;
  DISPATCH_TABLE[Opcode.I32_EQ.tag] = I32_EQ;
  DISPATCH_TABLE[Opcode.I32_NE.tag] = I32_NE;
  DISPATCH_TABLE[Opcode.I32_LT_U.tag] = I32_LT_U;
  DISPATCH_TABLE[Opcode.I32_LT_S.tag] = I32_LT_S;
  DISPATCH_TABLE[Opcode.I32_LE_S.tag] = I32_LE_S;
  DISPATCH_TABLE[Opcode.I32_GT_U.tag] = I32_GT_U;
  DISPATCH_TABLE[Opcode.I32_LE_U.tag] = I32_LE_U;
  DISPATCH_TABLE[Opcode.I32_GT_S.tag] = I32_GT_S;
  DISPATCH_TABLE[Opcode.I32_GE_U.tag] = I32_GE_U;
  DISPATCH_TABLE[Opcode.I32_GE_S.tag] = I32_GE_S;
  DISPATCH_TABLE[Opcode.I32_AND.tag] = I32_AND;
  DISPATCH_TABLE[Opcode.I32_OR.tag] = I32_OR;
  DISPATCH_TABLE[Opcode.I32_XOR.tag] = I32_XOR;
  DISPATCH_TABLE[Opcode.I32_SHL.tag] = I32_SHL;
  DISPATCH_TABLE[Opcode.I32_SHR_U.tag] = I32_SHR_U;
  DISPATCH_TABLE[Opcode.I32_SHR_S.tag] = I32_SHR_S;
  DISPATCH_TABLE[Opcode.I32_ROTL.tag] = I32_ROTL;
  DISPATCH_TABLE[Opcode.I32_ROTR.tag] = I32_ROTR;
  DISPATCH_TABLE[Opcode.I32_CLZ.tag] = I32_CLZ;
  DISPATCH_TABLE[Opcode.I32_CTZ.tag] = I32_CTZ;
  DISPATCH_TABLE[Opcode.I32_POPCNT.tag] = I32_POPCNT;
  DISPATCH_TABLE[Opcode.I32_REM_S.tag] = I32_REM_S;
  DISPATCH_TABLE[Opcode.I32_REM_U.tag] = I32_REM_U;
  DISPATCH_TABLE[Opcode.I32_EXTEND8_S.tag] = I32_EXTEND8_S;
  DISPATCH_TABLE[Opcode.I32_EXTEND16_S.tag] = I32_EXTEND16_S;
  DISPATCH_TABLE[Opcode.I64_CONST.tag] = I64_CONST;
  DISPATCH_TABLE[Opcode.I64_ADD.tag] = I64_ADD;
  DISPATCH_TABLE[Opcode.I64_SUB.tag] = I64_SUB;
  DISPATCH_TABLE[Opcode.I64_MUL.tag] = I64_MUL;
  DISPATCH_TABLE[Opcode.I64_DIV_S.tag] = I64_DIV_S;
  DISPATCH_TABLE[Opcode.I64_DIV_U.tag] = I64_DIV_U;
  DISPATCH_TABLE[Opcode.I64_REM_S.tag] = I64_REM_S;
  DISPATCH_TABLE[Opcode.I64_REM_U.tag] = I64_REM_U;
  DISPATCH_TABLE[Opcode.I64_AND.tag] = I64_AND;
  DISPATCH_TABLE[Opcode.I64_OR.tag] = I64_OR;
  DISPATCH_TABLE[Opcode.I64_XOR.tag] = I64_XOR;
  DISPATCH_TABLE[Opcode.I64_SHL.tag] = I64_SHL;
  DISPATCH_TABLE[Opcode.I64_SHR_U.tag] = I64_SHR_U;
  DISPATCH_TABLE[Opcode.I64_SHR_S.tag] = I64_SHR_S;
  DISPATCH_TABLE[Opcode.I64_ROTL.tag] = I64_ROTL;
  DISPATCH_TABLE[Opcode.I64_ROTR.tag] = I64_ROTR;
  DISPATCH_TABLE[Opcode.I64_CLZ.tag] = I64_CLZ;
  DISPATCH_TABLE[Opcode.I64_CTZ.tag] = I64_CTZ;
  DISPATCH_TABLE[Opcode.I64_POPCNT.tag] = I64_POPCNT;
  DISPATCH_TABLE[Opcode.I64_EQZ.tag] = I64_EQZ;
  DISPATCH_TABLE[Opcode.I64_EQ.tag] = I64_EQ;
  DISPATCH_TABLE[Opcode.I64_NE.tag] = I64_NE;
  DISPATCH_TABLE[Opcode.I64_LT_S.tag] = I64_LT_S;
  DISPATCH_TABLE[Opcode.I64_LT_U.tag] = I64_LT_U;
  DISPATCH_TABLE[Opcode.I64_LE_S.tag] = I64_LE_S;
  DISPATCH_TABLE[Opcode.I64_LE_U.tag] = I64_LE_U;
  DISPATCH_TABLE[Opcode.I64_GT_S.tag] = I64_GT_S;
  DISPATCH_TABLE[Opcode.I64_GT_U.tag] = I64_GT_U;
  DISPATCH_TABLE[Opcode.I64_GE_S.tag] = I64_GE_S;
  DISPATCH_TABLE[Opcode.I64_GE_U.tag] = I64_GE_U;
  DISPATCH_TABLE[Opcode.I64_EXTEND8_S.tag] = I64_EXTEND8_S;
  DISPATCH_TABLE[Opcode.I64_EXTEND16_S.tag] = I64_EXTEND16_S;
  DISPATCH_TABLE[Opcode.I64_EXTEND32_S.tag] = I64_EXTEND32_S;
  DISPATCH_TABLE[Opcode.F32_CONST.tag] = F32_CONST;
  DISPATCH_TABLE[Opcode.F32_ADD.tag] = F32_ADD;
  DISPATCH_TABLE[Opcode.F32_SUB.tag] = F32_SUB;
  DISPATCH_TABLE[Opcode.F32_MUL.tag] = F32_MUL;
  DISPATCH_TABLE[Opcode.F32_DIV.tag] = F32_DIV;
  DISPATCH_TABLE[Opcode.F32_SQRT.tag] = F32_SQRT;
  DISPATCH_TABLE[Opcode.F32_EQ.tag] = F32_EQ;
  DISPATCH_TABLE[Opcode.F32_NE.tag] = F32_NE;
  DISPATCH_TABLE[Opcode.F32_LT.tag] = F32_LT;
  DISPATCH_TABLE[Opcode.F32_LE.tag] = F32_LE;
  DISPATCH_TABLE[Opcode.F32_GT.tag] = F32_GT;
  DISPATCH_TABLE[Opcode.BR.tag] = BR;
  DISPATCH_TABLE[Opcode.BR_IF.tag] = BR_IF;
  DISPATCH_TABLE[Opcode.BR_TABLE.tag] = BR_TABLE;
  DISPATCH_TABLE[Opcode.BLOCK.tag] = BLOCK;
  DISPATCH_TABLE[Opcode.LOOP.tag] = LOOP;
  DISPATCH_TABLE[Opcode.TRY.tag] = TRY;
  DISPATCH_TABLE[Opcode.IF.tag] = IF;
  DISPATCH_TABLE[Opcode.ELSE.tag] = ELSE;
  DISPATCH_TABLE[Opcode.END.tag] = END;
  DISPATCH_TABLE[Opcode.RETURN.tag] = RETURN;
  DISPATCH_TABLE[Opcode.REF_NULL.tag] = REF_NULL;
  DISPATCH_TABLE[Opcode.REF_IS_NULL.tag] = REF_IS_NULL;
  DISPATCH_TABLE[Opcode.REF_AS_NON_NULL.tag] = REF_AS_NON_NULL;
  DISPATCH_TABLE[Opcode.STRUCT_NEW.tag] = STRUCT_NEW;
  DISPATCH_TABLE[Opcode.STRUCT_GET.tag] = STRUCT_GET;
  DISPATCH_TABLE[Opcode.STRUCT_GET_S.tag] = STRUCT_GET_S;
  DISPATCH_TABLE[Opcode.STRUCT_GET_U.tag] = STRUCT_GET_U;
  DISPATCH_TABLE[Opcode.I32_LOAD.tag] = I32_LOAD;
  DISPATCH_TABLE[Opcode.I32_LOAD8_U.tag] = I32_LOAD8_U;
  DISPATCH_TABLE[Opcode.I32_LOAD16_S.tag] = I32_LOAD16_S;
  DISPATCH_TABLE[Opcode.I64_LOAD.tag] = I64_LOAD;
  DISPATCH_TABLE[Opcode.F32_LOAD.tag] = F32_LOAD;
  DISPATCH_TABLE[Opcode.F64_LOAD.tag] = F64_LOAD;
  DISPATCH_TABLE[Opcode.I32_STORE.tag] = I32_STORE;
  DISPATCH_TABLE[Opcode.I32_STORE8.tag] = I32_STORE8;
  DISPATCH_TABLE[Opcode.I32_STORE16.tag] = I32_STORE16;
  DISPATCH_TABLE[Opcode.I64_STORE.tag] = I64_STORE;
  DISPATCH_TABLE[Opcode.F32_STORE.tag] = F32_STORE;
  DISPATCH_TABLE[Opcode.F64_STORE.tag] = F64_STORE;
  return DISPATCH_TABLE;
}
var module: Module;
var codeptr: CodePtr;
var opcode: Opcode;
var opcode_pos: int; // not used much, because interpreter uses codeptr.pos
var DISPATCH_TABLE: Array<void -> void> = build_dispatch_table();
var local_types: Vector<TypeVar>;
var stack: ArrayStack<TypeVar>;
var globals: Vector<TypeVar>;
var rets: Array<TypeVar>;

// steal sidetable stuff from existing validator,
// to support custom sidetable stuff I think we can keep ControlEntry but replace SidetableBuilder
var ctl_stack: ArrayStack<ControlEntry>; 
var ctlxfer: CBDSidetableBuilder;
var ctl_top: ControlEntry;

// stolen from CodeValidator.v3
def pushControl(opcode: u16, params: Array<ValueType>, results: Array<ValueType>, val_stack_top: int) -> ControlEntry {
    var ctl = ctl_stack.next();
    if (ctl != null) { // FAST: reuse previous ControlEntry object
        ctl_stack.top++;
    } else { // allocate and cache new ControlEntry object
        ctl = ControlEntry.new();
        ctl_stack.push(ctl);
    }
    ctl_top = ctl;
    ctl.start_pos = codeptr.pos;
    ctl.delegate_pos = codeptr.pos;
    ctl.start_opcode = opcode;
    ctl.sidetable_pos = -1;
    ctl.params = params;
    ctl.results = results;
    ctl.val_stack_top = val_stack_top;
    ctl.reachable = true;
    ctl.first_ref = -1;
    ctl.else_ref = -1;
    ctl.undo_init_list = null;
    return ctl;
}

def popTypes(ts: Array<ValueType>) {
    for (i = ts.length - 1; i >= 0; i -= 1) pop_Value(typeVarFromValType(ts[i]));
}

def pushTypes(ts: Array<ValueType>) {
    for (i < ts.length) push_Value(typeVarFromValType(ts[i]), typeVarFromValType(ts[i]));
}

// Constants
// def HAS_MEM_INDEX = 0x40u;
def HAS_MEM_INDEX = TypeVar.U32;

def f32_reinterpret_u32(i: TypeVar.U32) -> TypeVar.F32;
def f64_reinterpret_u64(i: TypeVar.U64) -> TypeVar.F64;
def u32_reinterpret_f32(f: TypeVar.F32) -> TypeVar.U32;
def u64_reinterpret_f64(f: TypeVar.F64) -> TypeVar.U64;

// U64
def U32_plus(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_minus(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_times(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_div(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_div_s(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_rem_s(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_rem_u(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_lt(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_lte(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_lt_s(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_le_s(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_gt(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_gt_s(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_ge_s(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_ge(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_equals(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_not_equals(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_and(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_or(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;

def U32_clz(x: TypeVar.U32) => TypeVar.U32;
def U32_ctz(x: TypeVar.U32) => TypeVar.U32;
def U32_popcnt(x: TypeVar.U32) => TypeVar.U32;
def U32_shl(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_shr_u(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_shr_s(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_rotl(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;
def U32_rotr(lhs: TypeVar.U32, rhs: TypeVar.U32) => TypeVar.U32;

def U32_extend8_s(x: TypeVar.U32) -> TypeVar.U32;
def U32_extend16_s(x: TypeVar.U32) -> TypeVar.U32;

// U64
def U64_plus(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_minus(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_times(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_div(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_div_s(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_rem_s(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_rem_u(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_lt(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_lte(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_lt_s(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_le_s(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_gt(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_gt_s(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_ge_s(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_ge(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_equals(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_not_equals(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_and(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_or(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;

def U64_clz(x: TypeVar.U64) => TypeVar.U64;
def U64_ctz(x: TypeVar.U64) => TypeVar.U64;
def U64_popcnt(x: TypeVar.U64) => TypeVar.U64;
def U64_shl(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_shr_u(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_shr_s(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_rotl(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;
def U64_rotr(lhs: TypeVar.U64, rhs: TypeVar.U64) => TypeVar.U64;

def U64_extend8_s(x: TypeVar.U64) -> TypeVar.U64;
def U64_extend16_s(x: TypeVar.U64) -> TypeVar.U64;
def U64_extend32_s(x: TypeVar.U64) -> TypeVar.U64;

// F32
def F32_equals = TypeVar.F32.testop(float.==);
def F32_not_equals = TypeVar.F32.testop(float.==);
def F32_lt = TypeVar.F32.testop(float.<);
def F32_lte = TypeVar.F32.testop(float.<=);
def F32_gt = TypeVar.F32.testop(float.>);
def F32_plus = TypeVar.F32.binop(float.+);
def F32_minus = TypeVar.F32.binop(float.-);
def F32_div = TypeVar.F32.binop(float./);
def F32_times = TypeVar.F32.binop(float.*);
def F32_sqrt = fun (x: TypeVar.F32) => x;

def object_Null() -> TypeVar.Object => TypeVar.Object;
def object_isNull(o: TypeVar.Object) => TypeVar.U32;
def object_New(sig: HeapTypeDecl) -> TypeVar.Object => TypeVar.Object;

def typeVarFromValType(vt: ValueType) -> TypeVar {
    match (vt) {
        I32 => return TypeVar.U32;
        I64 => return TypeVar.U64;
        F32 => return TypeVar.F32;
        F64 => return TypeVar.F64;
        V128 => return TypeVar.V128;
        Ref => return TypeVar.Object;
        Host => return TypeVar.Object;
        BOTTOM => return TypeVar.Bot(null);
    }
}

def valTypeFromTypeVar(tv: TypeVar) -> ValueType {
    match (tv) {
        U32 => return ValueType.I32;
        U64 => return ValueType.I64;
        F32 => return ValueType.F32;
        F64 => return ValueType.F64;
        V128 => return ValueType.V128;
        Object => return ValueTypes.ANYREF;
        Bot(_) => return ValueType.BOTTOM;
        U8 => return ValueType.BOTTOM; // XXX ? could be i32
        U16 => return ValueType.BOTTOM;
    }
}

def to_true(x: TypeVar.U32) => true;
def rtcast_byte(x: u8) => TypeVar.U32;
def rtcast_u32(x: u32) => TypeVar.U32;
def rtcast_u64(x: u64) => TypeVar.U64;
def rtcast_i32 = rtcast_u32;
def rtcast_f32(x: float) => TypeVar.F32;

def U32_maybeTrue(x: TypeVar.U32) -> bool => true;
def U32_maybeFalse(x: TypeVar.U32) -> bool => true;
def U64_maybeTrue(x: TypeVar.U64) -> bool => true;
def U64_maybeFalse(x: TypeVar.U64) -> bool => true;
def bool_maybeTrue(x: bool) -> bool => true;
def bool_maybeFalse(x: bool) -> bool => true;

enum FieldKind {
    U8, U16, U32, U64, F32, F64, V128, REF
}
component FieldKinds {
    def fromTag(t: int) -> FieldKind {
        for (fk in FieldKind.set.all) if (t == fk.tag) return fk;
        return FieldKind.U8;
    }
}

def imm_readULEB32() -> u32 => codeptr.read_uleb32();
def imm_readULEB64() -> u64 => codeptr.read_uleb64();

def imm_readILEB32() -> u32 => u32.view(codeptr.read_sleb32());
def imm_readILEB64() -> u64 => u32.view(codeptr.read_sleb64());

def imm_readU8() -> u8 {
    return codeptr.read1();
}

def imm_readBlockType() -> (Array<ValueType>, Array<ValueType>) {
    def bt = codeptr.read_BlockTypeCode();
    return bt.toAbstractBlockType(module);
}

def imm_readLabels() -> Array<u31> {
    return codeptr.read_labels();
}

def pop_u32() -> TypeVar.U32 {
    return stack.pop().unbox_u32();
}
def pop_u64() -> TypeVar.U64 {
    return stack.pop().unbox_u64();
}
def pop_f32() -> TypeVar.F32 {
    return stack.pop().unbox_f32();
}
def pop_f64() -> TypeVar.F64 {
    return stack.pop().unbox_f64();
}
def pop_v128() -> TypeVar.V128 {
    return stack.pop().unbox_v128();
}
def pop_Object() -> TypeVar.Object {
    return stack.pop().unbox_Object();
}
def pop_Value(tv: TypeVar) -> TypeVar {
    def actual = stack.pop();
    if (tv.matches(actual)) return tv;
    return invalid_t(tv);
}

def push_u32(v: TypeVar.U32) {
    stack.push(v);
}
def push_u64(v: TypeVar.U64) {
    stack.push(TypeVar.U64);
}
def push_f32(v: TypeVar.F32) {
    stack.push(TypeVar.F32);
}
def push_f64(v: TypeVar.F64) {
    stack.push(TypeVar.F64);
}
def push_v128(v: TypeVar.V128) {
    stack.push(TypeVar.V128);
}
def push_Object(v: TypeVar.Object) {
    stack.push(v);
}
def push_Value(tv: TypeVar, v: TypeVar) {
    if (!tv.matches(v)) invalid();
    stack.push(tv);
}

// Local variables.
def getLocal(tv: TypeVar, index: u32) -> TypeVar {
    if (!tv.matches(stack.elems[index])) invalid();
    return tv;
}
def setLocal(tv: TypeVar, index: u32, v: TypeVar) {
    if (!tv.matches(v)) invalid();
    stack.elems[index] = tv;
}

// Global variables.
def getGlobal(tv: TypeVar, index: u32) -> TypeVar {
    return globals[int.view(index)];
}
def setGlobal(tv: TypeVar, index: u32, v: TypeVar) {
    globals[int.view(index)] = v;
}

// Function context.
def f_getLabel(depth: u32) -> ControlEntry {
    return ctl_stack.elems[ctl_stack.top - int.view(depth) - 1];
}

def f_getLocalType(index: u32) -> TypeVar {
    return local_types[int.view(index)];
}

def f_getTopOfStackType() -> TypeVar {
    return stack.peek();
}

// Module context.
def m_getGlobalType(index: u32) -> TypeVar {
    return globals[int.view(index)];
}
def m_getFieldKind(struct_index: u32, field_index: u32) -> FieldKind {
    def ht = module.heaptypes[int.view(struct_index)];
    def decl = StructDecl.!(ht);
    def st = decl.field_types[field_index];
    match (st.valtype) {
        BOTTOM => return FieldKind.REF;
        I32 => return FieldKind.U32;
        I64 => return FieldKind.U64;
        F32 => return FieldKind.F32;
        F64 => return FieldKind.F64;
        V128 => return FieldKind.V128;
        Host => return FieldKind.REF;
        Ref => return FieldKind.REF;
    }
}
def m_getFieldOffset(struct_index: u32, field_index: u32) -> i32 {
    return i32.!(field_index); // TODO
}
def m_isMemory64(memory_index: u32) -> bool => false; // TODO mem64
def m_isTable64(memory_index: u32) -> bool => false;
def m_getFuncSignature(func_index: u32) -> SigDecl {
    return null;
}
def m_getSignature(sig_index: u32) -> HeapTypeDecl {
    return module.heaptypes[int.view(sig_index)];
}

// Instance context.
def i_getTableFunction64(table_index: u32, sig: Decl, func_index: TypeVar.U64) -> CBDFunction;
def i_getTableFunction32(table_index: u32, sig: Decl, func_index: TypeVar.U32) -> CBDFunction;
def i_getFunction(func_index: u32) => CBDFunction.new(module.functions[int.view(func_index)]);

// Control flow.
def doCall(sig: Decl, target: CBDFunction) {
    for (i = target.args.length - 1; i >= 0; i -= 1) pop_Value(target.args[i]);
    for (i < target.rets.length) push_Value(target.rets[i], target.rets[i]);
}

def doReturnCall = doCall;

def doBranch(label: ControlEntry) {
    def args = if(label.start_opcode == Opcode.LOOP.code, label.params, label.results);
    popTypes(args);
    pushTypes(args);
}

def doSwitch(labels: Array<u31>, key: TypeVar.U32) {
    var arity = -1;
    for (i < labels.length) {
        // copying from CodeValidator.v3
        def target = f_getLabel(labels[i]);
        if (target == null) return;
        def args = labelArgs(target);
        if (arity < 0) arity = args.length;
        else if (arity != args.length) invalid();
        // TODO: check args
    }
}

def doFallthru() {
}

// Machine intrinsics.
def mach_readStructField_u8(obj: TypeVar.Object, offset: i32) => TypeVar.U32;
def mach_readStructField_u16(obj: TypeVar.Object, offset: i32) => TypeVar.U32;
def mach_readStructField_u32(obj: TypeVar.Object, offset: i32) => TypeVar.U32;
def mach_readStructField_u64(obj: TypeVar.Object, offset: i32) => TypeVar.U64;
def mach_readStructField_f32(obj: TypeVar.Object, offset: i32) => TypeVar.F32;
def mach_readStructField_f64(obj: TypeVar.Object, offset: i32) => TypeVar.F64;
def mach_readStructField_v128(obj: TypeVar.Object, offset: i32) => TypeVar.V128;
def mach_readStructField_Object(obj: TypeVar.Object, offset: i32) => TypeVar.Object;

// TODO: validate read/write
def mach_readMemory64_u8(memory_index: u32, index: TypeVar.U64, offset: u64) => TypeVar.U32;
def mach_readMemory32_u8(memory_index: u32, index: TypeVar.U32, offset: u32) => TypeVar.U32;
def mach_readMemory64_u16(memory_index: u32, index: TypeVar.U64, offset: u64) => TypeVar.U32;
def mach_readMemory32_u16(memory_index: u32, index: TypeVar.U32, offset: u32) => TypeVar.U32;
def mach_readMemory64_u32(memory_index: u32, index: TypeVar.U64, offset: u64) => TypeVar.U32;
def mach_readMemory32_u32(memory_index: u32, index: TypeVar.U32, offset: u32) => TypeVar.U32;
def mach_readMemory64_u64(memory_index: u32, index: TypeVar.U64, offset: u64) => TypeVar.U64;
def mach_readMemory32_u64(memory_index: u32, index: TypeVar.U32, offset: u32) => TypeVar.U64;
def mach_readMemory64_f32(memory_index: u32, index: TypeVar.U64, offset: u64) => TypeVar.F32;
def mach_readMemory32_f32(memory_index: u32, index: TypeVar.U32, offset: u32) => TypeVar.F32;
def mach_readMemory64_f64(memory_index: u32, index: TypeVar.U64, offset: u64) => TypeVar.F64;
def mach_readMemory32_f64(memory_index: u32, index: TypeVar.U32, offset: u32) => TypeVar.F64;

def mach_writeMemory64_u8(memory_index: u32, index: TypeVar.U64, offset: u64, val: TypeVar.U32) => void;
def mach_writeMemory32_u8(memory_index: u32, index: TypeVar.U32, offset: u32, val: TypeVar.U32) => void;
def mach_writeMemory64_u16(memory_index: u32, index: TypeVar.U64, offset: u64, val: TypeVar.U32) => void;
def mach_writeMemory32_u16(memory_index: u32, index: TypeVar.U32, offset: u32, val: TypeVar.U32) => void;
def mach_writeMemory64_u32(memory_index: u32, index: TypeVar.U64, offset: u64, val: TypeVar.U32) => void;
def mach_writeMemory32_u32(memory_index: u32, index: TypeVar.U32, offset: u32, val: TypeVar.U32) => void;
def mach_writeMemory64_u64(memory_index: u32, index: TypeVar.U64, offset: u64, val: TypeVar.U64) => void;
def mach_writeMemory32_u64(memory_index: u32, index: TypeVar.U32, offset: u32, val: TypeVar.U64) => void;
def mach_writeMemory64_f32(memory_index: u32, index: TypeVar.U64, offset: u64, val: TypeVar.F32) => void;
def mach_writeMemory32_f32(memory_index: u32, index: TypeVar.U32, offset: u32, val: TypeVar.F32) => void;
def mach_writeMemory64_f64(memory_index: u32, index: TypeVar.U64, offset: u64, val: TypeVar.F64) => void;
def mach_writeMemory32_f64(memory_index: u32, index: TypeVar.U32, offset: u32, val: TypeVar.F64) => void;

def mach_readTable64(table_index: u32, index: TypeVar.U64) => TypeVar.Object;
def mach_readTable32(table_index: u32, index: TypeVar.U32) => TypeVar.Object;

def mach_writeTable64(table_index: u32, index: TypeVar.U64, val: TypeVar.Object) => void;
def mach_writeTable32(table_index: u32, index: TypeVar.U32, val: TypeVar.Object) => void;

// Traps.
def invalid();
def trapNull() {
    // since this is a runtime trap only, 
    // we don't actually want to trap here
}
def trapUnreachable() {} // XXX: validator tries to validate unreachable code
def trapDivideByZero() {}
def trapDivideUnrepresentable() {}
def trapTableOOB() {}

def invalid_t<T>(t: T) -> T {
    invalid();
    return t;
}

def doBlock(bt: (Array<ValueType>, Array<ValueType>)) -> ControlEntry {
    def args = bt.0;
    def rets = bt.1;
    popTypes(args);
    pushTypes(args);
    pushControl(Opcode.BLOCK.code, args, rets, stack.top);
    return ctl_top;
}

def doLoop(bt: (Array<ValueType>, Array<ValueType>)) -> ControlEntry {
    def args = bt.0;
    def rets = bt.1;
    popTypes(args);
    pushTypes(args);
    pushControl(Opcode.LOOP.code, args, rets, stack.top);
    ctl_top.sidetable_pos = ctlxfer.sidetable.length;
    return ctl_top;
}

def doIf(bt: (Array<ValueType>, Array<ValueType>)) -> ControlEntry {
    def args = bt.0;
    def rets = bt.1;
    popTypes(args);
    pushTypes(args);
    def ctl = pushControl(Opcode.IF.code, args, rets, stack.top);
    return ctl;
}

def doElse() -> ControlEntry {
	if (ctl_top.start_opcode != Opcode.IF.code) invalid();
    def p = ctl_top.results;
    popTypes(p);
    stack.top = ctl_top.val_stack_top;
    pushTypes(p);

    ctl_top.start_opcode = opcode.code;
    ctl_top.reachable = true;
    stack.top = ctl_top.val_stack_top;
    pushTypes(ctl_top.params);

    return ctl_top;
}

def doEnd() {
    def p = ctl_top.results;
    popTypes(p);
    stack.top = ctl_top.val_stack_top;
    pushTypes(p);
    match (ctl_top.start_opcode) {
        Opcode.LOOP.code => {
            ctlxfer.bind(ctl_top, ctl_top.start_pos, ctl_top.sidetable_pos);
        }
        Opcode.IF.code => {
            // one-armed if; simulate an empty else clause
            stack.top = ctl_top.val_stack_top;
            ctl_top.reachable = true;
            pushTypes(ctl_top.params);
            popTypes(ctl_top.results);
            ctlxfer.bindElse(ctl_top, codeptr.pos);
            ctlxfer.bind(ctl_top, codeptr.pos, ctlxfer.sidetable.length);
        }
        _ => {
            ctlxfer.bind(ctl_top, codeptr.pos, ctlxfer.sidetable.length);
        }
    }
    ctl_stack.pop();
    ctl_top = ctl_stack.peek();
}

def doReturn() {
    for (i = rets.length - 1; i >= 0; i -= 1) pop_Value(rets[i]);
    for (i < rets.length) push_Value(rets[i], rets[i]);
}

def doTry(bt: (Array<ValueType>, Array<ValueType>)) {
    return;
}

def f_isAtEnd() -> bool {
    return codeptr.pos >= codeptr.data.length;
}

def push_locals(count: u32, vtc: ValueTypeCode) {
    var tv: TypeVar;
    match (vtc.code) {
        BpTypeCode.I32.val => tv = TypeVar.U32;
        BpTypeCode.I64.val => tv = TypeVar.U64;
        BpTypeCode.F32.val => tv = TypeVar.F32;
        BpTypeCode.F64.val => tv = TypeVar.F64;
        BpTypeCode.V128.val => tv = TypeVar.V128;
        BpTypeCode.FUNCREF.val => tv = TypeVar.Object;
        BpTypeCode.EXTERNREF.val => tv = TypeVar.Object;
        BpTypeCode.ANYREF.val => tv = TypeVar.Object;
        BpTypeCode.EQREF.val => tv = TypeVar.Object;
        BpTypeCode.I31REF.val => tv = TypeVar.Object;
        BpTypeCode.STRUCTREF.val => tv = TypeVar.Object;
        BpTypeCode.ARRAYREF.val => tv = TypeVar.Object;
        _ => tv = TypeVar.Object; // default to Object for unknown ref types
    }
 
    for (i < count) local_types.put(tv);
    for (i < count) stack.push(tv);
}

component Validator {
    def init(new_module: Module, args: Array<int>) {
        module = new_module;
        
        globals = Vector.new();
        for (i < module.globals.length) {
            def module_global = module.globals[i];
            var global_type = typeVarFromValType(module_global.valtype);
            globals.put(global_type);
        }
    }
    
    def init_function(code: Array<byte>, args: Array<TypeVar>, locals: Array<TypeVar>, ret: Array<TypeVar>) {
        codeptr = CodePtr.new(code);
        local_types = Vector.new();
        stack = ArrayStack.new();

        ctl_stack = ArrayStack.new();
        ctlxfer = CBDSidetableBuilder.new();
        ctl_top = null;

        opcode_pos = codeptr.pos;
        pushControl(Opcode.UNREACHABLE.code, Arrays.map(args, valTypeFromTypeVar), Arrays.map(ret, valTypeFromTypeVar), 0);

        for (a in args) local_types.put(a);
        for (a in args) stack.push(a);

        rets = ret;
    }

    def dispatch() {
        codeptr.iterate_local_codes(push_locals);
        ctlxfer.reset(codeptr.pos);
        while (codeptr.pos < codeptr.data.length) {
            opcode_pos = codeptr.pos;
            opcode = codeptr.read_opcode();
            // System.puti(opcode_pos); System.puts(": ");
            // for (i < stack.top) {
            //     System.puts(stack.elems[i].long_str()); System.puts(", ");
            // }
            // System.ln();
            System.puts(opcode.mnemonic);
            System.ln();
            DISPATCH_TABLE[opcode.tag]();
        }
    }

    def build_sidetable() -> Array<u8> => ctlxfer.extract();
}

def labelArgs(target: ControlEntry) -> Array<ValueType> {
    if (target.start_opcode == Opcode.LOOP.code) return target.params;
    else return target.results;
}

layout STEntry_Is64 {
    +0  is64: bool;
    =1;
}
// I think we would have to add stuff to the sidetable
// annotation to be able to generate this
layout STEntry_Label {
    +0  label: Sidetable_BrEntry;
    =16;
}
layout STEntry_KindOffset {
    +0  offset: int;
    +4  kind: FieldKind;
    =5;
}
layout STEntry_Labels {
    +0  labels: u32; // what's the max number of labels?
    =4;
}

class CBDSidetableBuilder {
    def sidetable = Vector<u8>.new();
    var start_pos: int;

    def allocate(size: int) -> int {
        def end = sidetable.length;
        sidetable.resize(end + size);
        return end;
    }

    def put_br_entry(dpc: int, valcount: int, popcount: int, dstp: int) {
        def end = allocate(Sidetable_BrEntry.size);
        def new_entry = Ref<Sidetable_BrEntry>.at(sidetable.array, end);
        new_entry.pc_delta = dpc;
        new_entry.valcount = valcount;
        new_entry.popcount = popcount;
        new_entry.stp_delta = dstp;
    }

    def reset(start_pos: int) {
		this.start_pos = start_pos;
		this.sidetable.resize(0);
	}
	// Emit a control entry that references {target} from the pc position {pc}.
	def ref0(target: ControlEntry, pos: int) {
		refV(target, pos, 0, 0);
	}
	// Emit a control entry for an else that references the else label of {target} from {pos}.
	def refElse(target: ControlEntry, pos: int) {
		var pc = rel(pos);
		var stp = sidetable.length;
		target.else_ref = stp;

		put_br_entry(pc, 0, 0, -1);
	}
	// Bind the else label for {target} at {pos}, resolving references to it.
	def bindElse(target: ControlEntry, pos: int) {
		bind0(target, target.else_ref, pos, sidetable.length);
		target.else_ref = -1;
	}
	// Emit a sidetable entry for a branch to {target} from {pos} with stack top {val_stack_top}.
	def refS(target: ControlEntry, pos: int, val_stack_top: int) {
		var valcount = labelArgs(target).length;
		var popcount = val_stack_top - valcount - target.val_stack_top;
		refV(target, pos, valcount, u23.view(popcount));
	}
	def refV(target: ControlEntry, pos: int, valcount: int, popcount: int) {
		var pc = rel(pos);
		var stp = sidetable.length;
		put_br_entry(pc, valcount, popcount, target.first_ref);
		target.first_ref = stp;
	}
	// ext:typed-continuation
	// Emit a sidetable entry for a resume operation.
	// def refR(n_args: int, n_handlers: int) {
	// 	Sidetables.putResumeEntry(sidetable, n_args, n_handlers);
	// }
	// Emit a sidetable entry for a catch entry or suspension handler.
	// {target} is nullable and is {null} for a switch handler.
	// def refC(target: ControlEntry, tag: TagDecl, exnref: bool, name: string) {
	// 	var handler_pc = 0;
	// 	var stp = sidetable.length;
	// 	var val_stk_top = if(target != null, target.val_stack_top, 0);
	// 	var first_ref = if(target != null, target.first_ref, -1);
	// 	if (Trace.validation) {
	// 		OUT.put1("    %s", name);
	// 		OUT.put3("(@+pc tag=%d exnref=%z vsp=%d", if(tag != null, tag.tag_index, -1), exnref, val_stk_top);
	// 		OUT.ln();
	// 	}
	// 	Sidetables.putCatchEntry(sidetable, handler_pc, val_stk_top, first_ref);
	// 	if (target != null) target.first_ref = stp;
	// }
	// Bind the label for {target} at {pos} and {sidetable_pos} and resolve references to it.
	def bind(target: ControlEntry, pos: int, sidetable_pos: int) {
		bind0(target, target.first_ref, pos, sidetable_pos);
		target.first_ref = -1;
	}
	def bind0(target: ControlEntry, stp: int, pos: int, sidetable_pos: int) {
		target.sidetable_pos = sidetable_pos;
		var pc = rel(pos);
		while (stp >= 0) {
            def br_entry = Ref<Sidetable_BrEntry>.at(sidetable.array, stp);
			var ni = br_entry.stp_delta;
			var pos = br_entry.pc_delta;
			var pc_delta = pc - pos;
            br_entry.pc_delta = pc_delta;
            br_entry.stp_delta = sidetable_pos - stp;
			stp = ni;
		}
	}
	// def rethrow(ex_slot: int, popcount: int) {
	// 	sidetable.put(ex_slot).put(0).put(popcount).put(0); // XXX: only need 1 entry for rethrow
	// }
	def rel(pos: int) -> int {
		return pos - start_pos;
	}
	def extract() -> Array<u8> {
		return sidetable.copy();
	}

    def put_Is64(is64: bool) {
        def end = allocate(STEntry_Is64.size);
        def entry = Ref<STEntry_Is64>.at(sidetable.array, end);
        entry.is64 = is64;
    }

    def put_KindOffset(kind: FieldKind, offset: i32) {
        def end = allocate(STEntry_KindOffset.size);
        def entry = Ref<STEntry_KindOffset>.at(sidetable.array, end);
        entry.kind = kind;
        entry.offset = offset;
    }

    def put_BR(label: ControlEntry) => refS(label, opcode_pos, stack.top);
    def put_BR_IF(label: ControlEntry) => refS(label, opcode_pos, stack.top);

    def put_IF(label: ControlEntry) {
        refElse(label, opcode_pos);
    }

    def put_ELSE(label: ControlEntry) {
        ref0(label, opcode_pos);
        bindElse(label, opcode_pos);
    }

    def put_BR_TABLE(labels: Array<u31>) {
        def end = allocate(STEntry_Labels.size);
        def start_entry = Ref<STEntry_Labels>.at(sidetable.array, end);
        start_entry.labels = u32.view(labels.length);
        
        for (i < labels.length) {
            def target = f_getLabel(labels[i]);
            refS(target, opcode_pos + i + 1, stack.top);
        }
    }

    def put_CALL_INDIRECT(is64: bool) => put_Is64(is64);

    def put_STRUCT_GET(kind: FieldKind, offset: i32) => put_KindOffset(kind, offset);
    def put_STRUCT_GET_S(kind: FieldKind, offset: i32) => put_KindOffset(kind, offset);
    def put_STRUCT_GET_U(kind: FieldKind, offset: i32) => put_KindOffset(kind, offset);
}
